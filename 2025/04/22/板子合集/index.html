<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>板子合集 | Mikasaの小屋</title><meta name="author" content="Mikasa"><meta name="copyright" content="Mikasa"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="板子合集"><meta name="application-name" content="板子合集"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="板子合集"><meta property="og:url" content="https://blade-of-mikasa.github.io/2025/04/22/%E6%9D%BF%E5%AD%90%E5%90%88%E9%9B%86/index.html"><meta property="og:site_name" content="Mikasaの小屋"><meta property="og:description" content="ACM题解 板子只是工具，重点还是锻炼思维. -3. 基本方针 如何思考?  冷静是有效思考的先决条件，无论何时，必须保证自己的思路清晰，不要在原地打转。 拆分: 在面对复杂的问题时，将问题拆分成若干个子问题，尝试逐个解决。 特例: 问题是否有平凡的情形，或是在满足若干特殊条件下的"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://blade-of-mikasa.github.io/img/default_cover.webp"><meta property="article:author" content="Mikasa"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://blade-of-mikasa.github.io/img/default_cover.webp"><meta name="description" content="ACM题解 板子只是工具，重点还是锻炼思维. -3. 基本方针 如何思考?  冷静是有效思考的先决条件，无论何时，必须保证自己的思路清晰，不要在原地打转。 拆分: 在面对复杂的问题时，将问题拆分成若干个子问题，尝试逐个解决。 特例: 问题是否有平凡的情形，或是在满足若干特殊条件下的"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="https://blade-of-mikasa.github.io/2025/04/22/%E6%9D%BF%E5%AD%90%E5%90%88%E9%9B%86/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: undefined,
  postHeadAiDescription: undefined,
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎回来！"},
  LA51: undefined,
  greetingBox: undefined,
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  music_page_default: "nav_music",
  root: '/',
  preloader: {"source":2},
  friends_vue_info: undefined,
  navMusic: true,
  mainTone: undefined,
  authorStatus: {"skills":["人間に、なりたいですわ！"]},
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: Mikasa","link":"链接: ","source":"来源: Mikasaの小屋","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: 'Mikasaの小屋',
  title: '板子合集',
  postAI: '',
  pageFillDescription: 'ACM题解, -3. 基本方针, 如何思考?, 学习路线!, -2. 奇妙思路, 选择那个?, 二分答案, 缩减范围, 抽象对象, -1. 基础模板类, 快速输入输出, __int128, 大整数, \(Z_p\), 0. 基础算法, 前缀 amp 宏, 排序, 二分 / 三分, 前缀和 / 差分, 离散化, 位运算, 双指针, 搜索, 1. 动态规划, 1.1 线性 DP, 1.2 区间 DP, 1.3 特殊 DP, 1.? DP 优化, 2. 贪心 / 构造, 构造, 贪心, 综合思维, 3. 字符串, 3.1 字符哈希, 3.2 字典树, 01字典树, 4. 数学, 4.1 基础算法, gcd, 快速幂, EXGCD, 逆元, mex, 4.2 数论 amp 组合数学, 数论基础, 质数, 斐波那契, 组合数, 整除分块, 4.3 博弈论, 5. 数据结构, 基础数据结构, 并查集, 树状数组, 线段树, 板子, 思想, 分块 amp 莫队, 6. 树上问题, 建树和遍历, LCA, 启发式合并, PS 神秘结论, 7. 图论, 7.1 建图和遍历, 7.2 最短路, 7.3 最小生成树, PS 神秘结论, 染色问题, 拉姆齐定理, 8. 计算几何, 9. 杂项, 离线, 根号分治, 带权二分, 01分数规划, 扫描线, 定积分, 异或哈希, 神秘结论, 骗分算法, 10. 良好性质 amp Trick, mex 问题, 排列问题, 异或问题, 回文串问题, 凸性, PS 观察题题解板子只是工具重点还是锻炼思维基本方针如何思考冷静是有效思考的先决条件无论何时必须保证自己的思路清晰不要在原地打转拆分在面对复杂的问题时将问题拆分成若干个子问题尝试逐个解决特例问题是否有平凡的情形或是在满足若干特殊条件下的解决方案对比这种情形与原先的问题枚举枚举比较小的例子观察情况不要困在某一个部分中如果它真的很困难经过尝试仍然没有思路试着先去思考其他的部分再思考其他的部分能否对这个子问题产生启发泛化尝试将问题泛化以凸显问题真正重要的条件或对比问题与其他模型的相似之处对比大问题与小问题的一般性与特殊性尝试借助各种工具或者各种类型的直观从不同的角度去观察尽量进行有效的思考在纸上将转化的过程一一写下便于进行进一步的观察当问题难以推进时将遇到的困难可能的解决方向可能有用的工具一一列出然后带着方向仔细观察问题的性质如果仍然想不出可能是被错误的思路干扰了先放一放考虑一些其他的题转换一下思路相信一切问题都是可做的学习路线第一阶段洛谷简单树和图树图数据结构字符串入门数学入门每天积累查缺补漏保持手感第二阶段每天打场学金银牌题算法计算几何字符串费用流暂定奇妙思路考什么思维算法的应用原理扩展选择那个探路一般只探一步多了说明做法假了二分答案特征最大化最小值最小化最大值可推广到全序集缩减范围利用不等式皮亚诺周期互质数对的范围估计异或不等式不等式观察性质改变枚举对象间隔质数的子序列计数最大区间和年浙江中医药大学程序设计竞赛同步赛抽象对象只关心所以转化成特定形式大小比较问题把原数组转换成基础模板类快速输入输出快速输入输出大整数数字转字符串逆序数位正负模整数环注意用到了基础算法前缀宏完全体类型转换快速位运算获得的的强制的为强制的为给加快速打印快速输入输出上面别动简化获得的的排序快速排序归并排序二分三分整数二分先按题意分为两个区间记为区间和区间区间的右端点区域的右端点区间被划分成和时使用区间的左端点区域的左端点区间被划分成和时使用返回第一个大于等于的地址返回第一个大于的地址浮点数二分一样分为区间和区间表示精度取决于题目对精度的要求通常要比题目要求高两个数量级三分本质还是二分只是判断区间时用了两个参数浮点数三分实数三分前缀和差分前缀和与差分可以看做逆运算但是处理手段略有不同前缀和容斥原理完成静态数组的区间查询一维前缀和二维前缀和第行列格子左上部分所有元素的和以为左上角为右下角的子矩阵的和为差分完成动态数组的区间修改一维差分给区间中的每个数加上二维差分差分矩阵给以为左上角为右下角的子矩阵中的所有元素加上离散化三步法排序去重非卡常用即为离散化后对应的下标原数据位运算异或和或返回的最后一位求的第位数字将第位变为将第位取反将最右边的置为去掉最右边的将最右边的置为判断奇偶性真为奇假为偶快速位运算超实用位运算函数总结知乎结论求异或不等式见构造专题可以想想什么时候等式成立异或不能保持序关系也就是说是错的双指针尺取法是否满足要求逛画展本题中用来判断是否完成所有作品避免了遍历数组值得学习环的非负前缀和子段给一个长的环找一个点使得展开得到数组的前缀和均为非负搜索以及其它参数结束条件剪枝表示号点已经被遍历过剪枝记忆化记录当前状态之后可直接调用最优性若当前答案已不是最优结束可行性若当前不可行结束动态规划关于初始化初始化不一定要满足定义而是要保证正确性线性背包问题背包问题采药背包问题变式装箱问题注意到数组大小完全背包问题疯狂的采药时间复杂度来自学长给出的时间优化时间复杂度可选性背包未我想到的是反悔贪心边走边拿能拿下就把拿到的记录到某个数据结构中拿不下就反悔从中用背包选反悔的实际上就是给状态转移加个判断满足就可以转移反之则不能对于该题还要注意考虑到价值和体积的大小背包的第二参量应为价值即表示当遍历到第个物品得到价值时花费体积的最小值故有改变参量的背包路径数字三角形数字三角形等跨度路线特定点不可取过河卒抵消标记抵消不等跨度的选路小点菜区间子序列子串问题最长单调子序列解法给出模板最长上升子序列未同下用表示最后一个接的馅饼为时总接到的馅饼的最大值有这个思路没啥大问题但是题目要求刚开始时在的位置暂时实现不了换一种第秒位于时接到馅饼数的最大值考虑到边界问题把和设置为可用滚动数组优化但是由于每次小循环时会读取假定是从到遍历那么如果直接去掉第一维那么在第一维为时更新之前已经把更新为了打鼹鼠用三个参量时间复杂度显然超时实际上给出的地鼠序列是按时间排好序的是可选性最长单调子序列记为最后打第个地鼠时打地鼠数的最大值曼哈顿距离简单说就是走格子数区别于欧氏距离快速求和先预处理求出从到的字符串的值表示最后一个为和为时的最少加号数给出数列分别表示的权重和两个人一起算的权重求出所有人权重的最小值记为结尾时权重的集合取其最小值给出数列求和最大的递增子序列记为最后一个选时的最大和未先按长排好序再宽然后连案例都过不去题目中三维是可以转动而更改的并且每种积木都是无限量供应如果我们把每个积木的选择情况全排列出来每个积木有种而且还是无限供应看似很麻烦但实际上高相同的积木最多只用一次所以只要把高不同的情况列出来就可以每个都有种然后对长进行降序排序对宽进行方程不变但是转移条件改为有是因为不去重另外的范围扩大到案例过去了但是了最长公共子序列解法记为最后一位为最后一位为时公共子序列长度最大值最长公共子串解法记为以结尾时公共子串最大长度最长的子序列且是子串想到这样一个问题已知字符串求既是的子序列又是的子串记为以最后一位是最后一位为时公共子序列长度最大值其他区间大师给定数列求等差子序列的个数注意单个元素也算等差子序列其中表示以结尾公差为的最大等差数列数快速求和给定一个数字字符串和问在中塞入最少多少个加号能使得表达式值为可行性剪枝最优性剪枝卡时的居然草过去了特殊状态压缩很经典的问题从优化至可解性从升至为在集合中从起点出发终点为的路径最短值则有吃奶酪枚举所有状态未分类最大的连续子段和最大子段和自己做的时候只想出前缀和穷举复杂度不要思维定式地用前缀和潜意识地认为子段和就比单项大的关键在于递推式所以重要的是找到局部的递推过程子串以结尾已经使用次的方案数题意从到每次可以使或者问数组最后有多少种可能的情况解遍历到以结尾时的数量由于操作是前面影响后面的所以用刷表法由递推关系可得当时当时初始化因为是不参与操作的时空复杂度细节防负加偏移滚动数组优化按题意取模表示最后一个值优化数据结构优化单调队列琪露诺注意这一步防止出现不可能的路径利用性质减少枚举给一个长度为的数组当且仅当以下条件符合时子序列才是好序列其长度至少为两个连续元素之间的绝对差是质数计算的良好子序列的个数将其输出为的模容易想到解法但是注意到第二层循环可以枚举所有质数优化至绝世好题利用按位取和的性质来做每次都要有一位共同的才能转移所以转移方程为贪心构造构造构造几乎离不开贪心构造的一种方法先找一个尽可能紧的上下界然后根据上下界来构造例如先证明然后以此为依据构造出一种的解从而证明这就是正解给定构造一个由个个构成的字符串使得所有子串的题解容易给出上下限对于在这个范围内的可以给出一种构造不妨假设那么先输出个然后交替输出最后输出剩下的结果必然符合要求故而上述范围是充要条件题意半皇后能攻击同行同列和同主对角线上的单元格也就是说她比皇后少了左下和右上的选择给定在的棋盘上至少放多少个半皇后使得所有点都能被直接攻击到构造一个答案解法棋子数量的理论下界假设放了颗棋子仅看横竖最多覆盖行列将剩下的格子平移可以拼成的正方形该正方形的条对角线都要由个棋子的对角线覆盖因此可以列出不等式化简得剩下如何构造没看懂贪心狄尔沃斯定理对于任意有限偏序集其最大反链中元素的数目必等于最小链划分中链的数目最长单调子序列令为最长上升子序列的末尾元素的最小值有单调不减反证可得故可以二分维护遍历原序列每次都从中找可替换的元素并替换若无即看题意全序集所有排序本质上都要求是全序集也就是两两元素一定能比较所以我们每次找出两个元素比较优先级即可这种题找出偏序关系然后排个序就行结论通过相邻交换使得序列单调的次数就是逆序对的数量反悔贪心问题遍历时每喝一个负值药水就把它放入优先队列按扣了多少血中之后遇到喝不了的负值药水时看看能不能反悔之前的药水最长的非负前缀和子序列防止时引发同理综合思维排列的最长公共子序列给出均为到的排列求最长公共子列的长度可证明的子序列均为的下标递增的子序列反之成立故而问题转化为求的最长递增子列是欸我喜欢你题意给定求思路由异或性质故而注意到为定值时对应唯一反之成立故当时不存在所有未出现的都有问题转化为求也就是解异或不等式我们转换为等价的不等式否则要考虑特判记为的位数为的前到位即右移位从高位到低位贪心构造如果则的第位赋否则赋字符串字符哈希模板必须是不太小的质数判断回文注意二分时要分奇偶因为有的回文串不一定有的回文串复杂度字典树字典树模板类获得的的强制的为强制的为给加每个结点存的是自己的异或后的最大值数学基础算法求的最大公因数最小公倍数数据结构维护考虑多元但是一般会枚举因子而非求出多元题意给定一个长的数组和整数求对于每个从中选择包含的个元素求所选元素的最大思路常规思路是正着分解因子来解决显然会显然包含的一定是的因子所以可以从小到大遍历然后更新的所有倍数的数量注意这样复杂度是调和的代码的所有倍数之和时的答案快速幂乘法快速幂求模板快速幂优化减小不必要的运算求解二元一次不定方程逆元逆元定义若则求单个逆元若是质数用费马小定理若且则有故而用快速幂求复杂度若不是质数暂时不会求以内所有逆元可能会有解法记那么有初始化注意静态区间求所有前后缀求后缀改下顺序数论组合数学数论基础勾股数任意一组勾股数必然有证明容斥可得中一定有的倍数和的倍数反证可得中一定有的倍数故而是的倍数质数质因数计数因数计数当时当时质数计数质数距离特别地互质距离质因数计数易算从小到大质数相乘增长很快判断单个素数小常数欧拉筛求前个数中所有素数斐波那契皮萨诺周期模意义下斐波那契数列的周期被称为皮萨诺周期记为有结论当且仅当时等号成立三角形假如大小为的可重集合中没有能构成三角形的三元组那么最坏情况大小最大的构造是斐波那契数列组合数第二类斯特林数将个不同的元素拆分成个集合的方案数记为通项公式递推式边界整除分块给一个长度为的数组求排序预处理问题等价于给定单调递增数列求暴力考虑优化对来说是的贡献是一样的所以枚举倍数然后每次计算出做出贡献的数的上下界平均复杂度注意可能出现除了最大的数外全是很小的数比如这样还是记忆化处理即可这样每次遍历时是一定会增加的否则直接用前一次的结果跳到下一个了最坏情况下也是调和级数之和故而最坏情况下的复杂度注意也是级别的如果用复杂度就是会被卡掉博弈论公平组合游戏浅谈算法博弈论博客园定义状态为当前必胜状态为当前必输必然要提及函数假定每个状态只有一个参量那么定义函数其中是的后继状态终止状态的值显然为并且值为的状态就是状态值不为的状态就是状态从结果倒推假如数据结构数据结构只能是工具有很多专精数据结构什么树状数组套权值线段树写的起飞的小朋友但是不会做题很多人会陷进去骗自己数据结构功能表查询区间可重复贡献莫队完成所有离线静态的区间查询处理复杂查询时容易实现并查集合并查询树状数组弱化版线段树查询区间不可重复贡献线段树宇宙尽头树增删查改基础数据结构前缀和数组见基础算法表第二维多开一点赋初值注意循环顺序算完一层才能算下一层题意给定数列和次询问每次询问给出求使得思路式转化为记则有结合律和可重复性故使用表单调栈单调栈能解决的问题就很少基本上都是求一个数列中符合要求的最近的数给出模板顺序要因题而异模板单调栈顺序要因题而异把栈里所有值都弹出了说明这个值是最优先的单调队列值得注意地是单调队列是一个双向队列单调队列和滑动窗口紧密相连也能用来优化一些最值给出模板设窗口大小为显然当时要一直塞入直到窗口已经有个值时才开始运作并查集用树的结构来合并两个集合也能以近乎的速度查询某个值是否在该集合中简化版向上走上提父节点完全体向上走上提父节点并查集的访问同个集合只访问一次树状数组线段树的泛用性大于树状数组但是树状数组比线段树简单对于一个数组差分可以修改区间加同一个数前缀和可以查询区间对单点的修改和查询可视为弱化的区间修改和查询如何看每个结点里存什么看知道小区间的什么才能推出大区间所以可能要存一些辅助信息树状数组调用时开线段树线段树线段树可以在的时间复杂度内实现单点修改区间修改区间查询区间求和求区间最大值求区间最小值等操作常数比较大由于最坏情况下区间会分裂成个情况如图最坏是两个四个所以约为板子单点修改区间修改模板类注意接口是注意缺省可能对合并造成影响序建树令为返回区间的答案范围更新需要成员缺省构造重载需要成员缺省构造重载贴海报在上先后给个线段线段之间会覆盖问最后有多少线段未被完全覆盖浮水法思想数据结构要配合各种用维护值域轴逆序对用离散化的值来当下标等价于从左往右每次查询所有大于的数量和然后在处单点修改记录详情二维数点离线按升序维护轴逆运算记录详情分块莫队分块建块单点修改区间最值分块区间操作类剪枝如果修改点不影响区间最值就不遍历树上问题建树和遍历遍历目前只会不带修带修太难倍增预处理查询先放到同一高度上移欧拉序表貌似很简单比上面那个好学很多预处理查询考完试再学启发式合并笔记启发式合并博客园给定个集合每个集合开始只有个数每次合并两个集合直接做显然是每次合并都选择较小的一个集合将它合并到较大的集合上看上去本质上没有改变但时间复杂度降低至因为对于每个元素每次合并一定是从小的集合合并到大的集合所以合并后的集合大小一定翻倍那么一个元素最多移动次总时间复杂度为给一个阶无向零图每次操作会连一条边或者询问所在连通块的第大顶点并查集维护最坏情况下时间复杂度为启发式合并优化到时间复杂度神秘结论时间戳预处理后能快速判断一个结点是否为的子孙祖先性质是的祖先综上可以通过单调性判断祖先查找所有子孙证明题意给个结点数的树和次询问每次询问给定结点和深度问的深度为的子孙包括有多少思路按深度开桶之后对每个通排序每次询问都可以在桶里二分下界是上界是复杂度代码图论建图和遍历个点条边点的入度出度建图邻接矩阵链式前向星略邻接表使用最多使用一个支持动态增加元素的数据结构构成的数组如存的是点的所有出边信息终点边权等双向图加下面代码查询是否存在从到的边若有多次查询可以先排序再二分查找遍历整张图搜索判环技术最短路应用边权条件算法时间复杂度单点到单点无权贪心最优搜索单点到所有点无权非负所有点之间无负环复杂度求最近点访问最近点更新距离加入队列封装求最近点访问最近点更新距离加入队列有限制的最短路华中农业大学第十三届程序设计竞赛同步赛每个点都有代价并且只能选小于的边问从起点到终点的最小代价小于时最小为多少二分答案可选性分层图最短路分层图问题难在建图加速点的最短路起始节点的实图和虚图相连加速点的实图单向连接虚图中的邻居节点图中有个节点有马骑马后速度加倍两个人从和出发问相遇的最短时间只能在节点上相遇多层不同权值图小雨坐地铁建层图其中第层作为中转站这样能避免的接图操作只要每个图与第一层相连即可飞行路线不同层之间单向链接否则上下横跳可以权到达所有点记录详情小的魔法华中农业大学第十四届程序设计竞赛新生赛同步赛最小生成树反证假如到不选最短边那么一定会选其他边使得两个点相连此时连上最短边构成环然后断开也一定是一颗生成树而且一定不比刚才的更不优故而得证克鲁斯卡尔升序遍历边每次如果不在同一个连通块上就连结有朴素做法和堆优化两种做法完全图时朴素做法更优暂时不会部落划分虚图题意给个城市分布在二维坐标上给城市配置发电厂要花费连结城市的电路花费问要使得所有城市都供电最少花费多少思路设一个虚结点表示供电的城市城市到虚结点的距离为然后跑一遍最小生成树即可神秘结论染色问题出入度均为的阶环对边的两点染色要求最后所有点都被染色方案数为拉姆齐定理在任何一个完全图中所有边用两种颜色中的一种着色后必然存在一个单色的完全子图表示在一个完全图中边用红色和蓝色着色后子图中必然存在一个以红色为边的阶完全图或以蓝色为边的阶完全图最著名的这意味着任意一个阶数大于等于的图要么原图上存在三元环要么补图上存在三元环给你一个长度为的数组处理个查询每个查询由两个整数组成赋值在每次查询中更新的值后应该确定是否存在三元组满足下面其一题解任意枚举个点必然能找到一种三元组计算几何由于精度问题需要一个相等判断函数杂项离线因题而异根号分治这是一种思想发现当比较大时满足一定规律比较小时能暴力当变量和变量乘积定值且既有做法又有做法时常用根号分治平衡复杂度给个矩阵每次查询一些行列不对称的信息暴力美学浅谈根号分治专栏题意给一个的矩阵和次询问每次给出问假如只保留矩阵的第行是否存在单调不减的列思路注意到是矩阵并且只问一个维度的信息考虑根号分治记当时预处理记录在矩阵第列中的第个单调不减序列中然后每次询问遍历所有看是否有复杂度当时预处理对每一列所有子数组是否单调不减总复杂度题意给定由构成的排列有两种操作交换和给出的初始值令执行次最后输出思路经典转图每个连通块上找点往后的点预处理可以求出假如不带修那么可以分块跑一共解决考虑怎么处理修点不难发现也可以解决显然交换和后只有前面的个和后面个点会受影响同理所以暴力维护就可以前进后退题意给一个长度为的序列有次询问每次询问给出问思路这类一步跳多少的题一般都是根号分治暴力求平均复杂度但是最坏情况想到前缀和但是如果对每个都求一次所有初始点的前缀和复杂度注意到当较大时不用预处理所有情况暴力计算就可以每次复杂度设分界点是当时预处理出所有初始点的前缀和复杂度当时暴力求解复杂度那么最坏复杂度是分界点易知取时最优所以最坏复杂度有点反直觉因为貌似不分类直接暴力的复杂度也不高但是假如所有都很小时那么每次暴力都是的因题而异带权二分解释定义只能操作次时收益的最大值这类题目基本都具有凹凸性如果你要选第一个物品第一次肯定会选当前能选择的最大值证明首先因为每次选择之后限制肯定更严如果第二次选择物品收益的比第一次大因为第一次限制比第二次小所以在第一次选择的时候肯定也可以选择第二次的与第一次选择了最优价值矛盾所以我们证明了也就是说是凸函数故而斜率具有单调性已知斜率要求出切点的对于给定的和只有相切时斜率为的直线与轴截距最大画图易证故而时就是要求的切点也就是说对于给定的条件就是时的条件所以我们利用来求出此时的并且保证复杂度较低要使得最大根据定义注意是未知的则有等价于操作次数无最大限制但是每操作一次都会惩罚时的最大收益板子题前面思考过程的省略直接解决取的次数无最大限制但是每取一段都会惩罚的最大收益这个问题可以解决目前还不会所以总复杂度分数规划扫描线给个线段问是否有一个区间使得其上覆盖有至少条线段或其他信息用一个差分数组记录信息对线段有从前到后遍历求的前缀和和比较即可复杂度定积分自适应辛普森辛普森法的思想是将被积区间分为若干小段每段套用二次函数的积分公式进行计算为了在保证精度的前提下改进速度我们每次判断当前段和二次函数的相似程度如果足够相似的话就直接代入公式计算否则将当前段分割成左右两段递归求解这就是自适应辛普森公式足够相似的话就直接返回否则分割成两段递归求解异或哈希利用异或的性质和哈希降低冲突的原理可以快速找到一个组合是否出现异或类双指针注意到排列中一定要有遍历所有的位置每次从开始向后找记录最大值注意到假如一个序列是以第位结束并且包含第位的那么其长度必然等于且不能大于也就是说这个排列必然是从第位到第位的利用的哈希前缀以及类桶的哈希前缀就可以判断然后倒序来一次再注意单独的神秘结论二元整数线性规划已知线性整数规划拓展骗分算法卡时注意对无用有些题目我们想不到正解就只能暴搜但是此类方法一般时间复杂度较高此时我们需要进行卡时通俗来讲就是进行时间限制让程序在达到这个时间后立马退出输出当前最优方案或许能碰中正确答案获得更多步骤分常见的卡时无解输出答案种类很少例如判断奇偶实例快速求和无卡时记录详情卡时记录详情随机化随机数调用取随机数随机打乱数组良好性质问题性质单调性左区间是且是右区间的左端点应用设集合初始为对于从到的每个整数依次进行如下操作令将与加入集合中求经过所有操作后带有的题排列问题性质是满射应用问题等价于一个各个点出入度均为的图常结合并查集查找连通块两个排列的可以转化成快速判断排列可以异或哈希结合律运算下交换顺序有一定不等式性质带有的题证明如果那么交换和一定不为易证证明如果是完全平方数那么交换和一定不出现完全平方数可以反证异或问题性质位运算很自然的契合贪心相同数量的放到高位优于放到低位所以假如要尽可能大的答案一般从高位到低位构造查询异或具有交换律无关顺序无后效性可以从集合的角度考虑异或是不进位加法有比较紧的不等式异或可视为伪随机分布故而可以估计概率用随机化算法异或有相消性这个用法很巧妙异或运算时不同位相互独立可以看成向量用线代的视角处理线性基应用异或哈希进制异或字典树见带有的题数组里除了一个数外每个数都出现了两次求这个数解法全部异或扩展进制异或假如一个数组里每个数都出现了次只有一个数除外那么进制异或为对所有数二进制的每一位都记录模意义下的位和这样保证空间复杂度回文串问题性质带有的题正解是双指针从后向前遍历有反例正解假解凸性一些凸性结构往往也有有贪心结构难点在于证明吧反证居多给定数字并且给出一种操作假如每次操作可选项不变且每次操作后在全序意义下变化方向一致定义是第次操作后全序意义下的最值可考虑每次的变化值单调观察题树上三角形题目详情题意给的有权树权值小于有次查询给出点和问和的简单路径上是否能找出三个点使得其权值组成一个三角形思路假如大小为的可重集合中没有一组三角形那么最坏情况大小最大的构造是斐波那契数列注意到时也就是说长度大于的链一定合法所以大于的链直接输出小于的链暴力即可复杂度其中是小于的最长路径给定一个数字构成的长度为的字符串插入个乘号或加号求结果的最小值暴力复杂度想一想贪心个数字有个空隙插入个符号相当于个数字里选两个相邻数字视为一个整体注意到和乘任何数都是所以尽可能拆成和其它数相乘乘其它数不改变值所以尽可能拆成和其它数相乘除去之外的数都相加而非相乘至于合并哪两个数字暴力求个里面选连续的两个也就是选一个共种情况复杂度枚举第和个数字合并后算式的最小值求第个和个数字合并之后的数组在原数组中占两位下面求组成算式的最小值有一项为最小值就是都乘起来答案是乘不改变值忽略除了和外所有数都是相加注意到有特殊情况或执行到这一步时绝对不为故对其与取较大值即可给一个只有字母的序列可以操作或者问能否变成题解注意到等价于后移一格同理可以前移一格但是位置不能互换故而除去所以后的等于并且中所有不能出现的比中出现的晚不能比中早反思我为什么没有想出来我的做法开始想到有条件后移和前移但是变化比较复杂所以不如思考和题意给定矩阵求所有子矩阵中位数的最小值思路注意到多次询问考虑转化成前缀和题目等价于第大数的最小值故而考虑二分答案如何判断中位数定义转化为范围内有至少个数小于等于故而具有单调性只关心大小关系所以把原矩阵元素转化成复杂度代码给三个数组求第大的解法算法对先降序排序注意到因此从大到小枚举数值时总是先枚举然后是故而可以从开始拓展每次把最大的弹出来然后在优先队列里加入',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-04-22 23:06:24',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><a id="site-name" href="/" accesskey="h"><div class="title">Mikasaの小屋</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"></div><div id="nav-right"><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="微信" src="/null"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="/null" target="_blank"><img class="post-qr-code-img" alt="支付宝" src="/null"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">音乐</div><span class="author-content-item-title">灵魂的碰撞💥</span></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/07/"><span class="card-archive-list-date">七月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/06/"><span class="card-archive-list-date">六月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">6</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/05/"><span class="card-archive-list-date">五月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">3</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/04/"><span class="card-archive-list-date">四月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">11</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/03/"><span class="card-archive-list-date">三月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">23</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2025/01/"><span class="card-archive-list-date">一月 2025</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">1</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/12/"><span class="card-archive-list-date">十二月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">5</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="article-meta tags"></span></div></div><h1 class="post-title" itemprop="name headline">板子合集</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2025-04-22T14:08:05.000Z" title="发表于 2025-04-22 22:08:05">2025-04-22</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2025-04-22T15:06:24.606Z" title="更新于 2025-04-22 23:06:24">2025-04-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为北京"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>北京</span></div></div></div><section class="main-hero-waves-area waves-area"><svg class="waves-svg" xmlns="http://www.w3.org/2000/svg" xlink="http://www.w3.org/1999/xlink" viewBox="0 24 150 28" preserveAspectRatio="none" shape-rendering="auto"><defs><path id="gentle-wave" d="M -160 44 c 30 0 58 -18 88 -18 s 58 18 88 18 s 58 -18 88 -18 s 58 18 88 18 v 44 h -352 Z"></path></defs><g class="parallax"><use href="#gentle-wave" x="48" y="0"></use><use href="#gentle-wave" x="48" y="3"></use><use href="#gentle-wave" x="48" y="5"></use><use href="#gentle-wave" x="48" y="7"></use></g></svg></section><div id="post-top-cover"><img class="nolazyload" id="post-top-bg" src="/img/default_cover.webp"></div></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container" itemscope itemtype="https://blade-of-mikasa.github.io/2025/04/22/%E6%9D%BF%E5%AD%90%E5%90%88%E9%9B%86/"><header><h1 id="CrawlerTitle" itemprop="name headline">板子合集</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">Mikasa</span><time itemprop="dateCreated datePublished" datetime="2025-04-22T14:08:05.000Z" title="发表于 2025-04-22 22:08:05">2025-04-22</time><time itemprop="dateCreated datePublished" datetime="2025-04-22T15:06:24.606Z" title="更新于 2025-04-22 23:06:24">2025-04-22</time></header><h1 id="acm题解">ACM题解</h1>
<p>板子只是工具，重点还是锻炼思维.</p>
<h2 id="基本方针">-3. 基本方针</h2>
<h4 id="如何思考">如何思考?</h4>
<ul>
<li><p>冷静是有效思考的先决条件，无论何时，必须保证自己的思路清晰，不要在原地打转。</p></li>
<li><p>拆分:
在面对复杂的问题时，将问题拆分成若干个子问题，尝试逐个解决。</p></li>
<li><p>特例:
问题是否有平凡的情形，或是在满足若干特殊条件下的解决方案？对比这种情形与原先的问题。</p></li>
<li><p>枚举: 枚举比较小的例子, 观察情况.</p></li>
<li><p>不要困在某一个部分中，如果它真的很困难，经过尝试仍然没有思路，试着先去思考其他的部分，再思考其他的部分能否对这个子问题产生启发。</p></li>
<li><p>泛化:
尝试将问题泛化（以凸显问题真正重要的条件），或对比问题与其他模型的相似之处。对比大问题与小问题的一般性与特殊性。</p></li>
<li><p>尝试借助各种工具，或者各种类型的直观，从不同的角度去观察。</p></li>
<li><p>尽量进行有效的思考，在纸上将转化的过程一一写下，便于进行进一步的观察。当问题难以推进时，将遇到的困难，可能的解决方向，可能有用的工具一一列出，然后带着方向仔细观察问题的性质。如果仍然想不出，可能是被错误的思路干扰了，先放一放，考虑一些其他的题转换一下思路。</p></li>
<li><p>相信一切问题都是可做的。</p></li>
</ul>
<h4 id="学习路线">学习路线!</h4>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">## 第一阶段</span></span><br><span class="line">洛谷 / atc: </span><br><span class="line">简单 DP -&gt; 树和图 / 树图DP -&gt; 数据结构 -&gt; 字符串入门/数学入门</span><br><span class="line"></span><br><span class="line">CF:</span><br><span class="line">每天 div3/edu 积累 Trick / 查缺补漏 / 保持手感</span><br><span class="line"></span><br><span class="line"><span class="section">## 第二阶段</span></span><br><span class="line">每天:</span><br><span class="line">gym 打 5h 场 + 学金银牌题算法(计算几何 / 字符串 / 费用流)</span><br><span class="line">暂定.</span><br></pre></td></tr></table></figure>
<h2 id="奇妙思路">-2. 奇妙思路</h2>
<p>考什么?</p>
<p>思维 + 算法的应用 or 原理扩展</p>
<h4 id="选择那个">选择那个?</h4>
<p>探路(一般只探一步, 多了说明做法假了)</p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2093/problem/G">Problem - G -
Codeforces</a></p>
<h4 id="二分答案"><strong>二分答案</strong></h4>
<p>特征: 最大化最小值 / 最小化最大值, 可推广到全序集.</p>
<h4 id="缩减范围"><strong>缩减范围</strong></h4>
<p><strong>利用不等式</strong></p>
<p>皮亚诺周期</p>
<p>互质数对的范围估计</p>
<p>异或不等式</p>
<p><span class="math inline">\(\text{mex}\)</span> 不等式</p>
<p><strong>观察性质, 改变枚举对象</strong></p>
<p>间隔质数的子序列计数</p>
<p><a
target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/103867/G">G-最大区间和_2025年浙江中医药大学程序设计竞赛（同步赛）</a></p>
<h4 id="抽象对象">抽象对象</h4>
<p>只关心XX, 所以转化成特定形式</p>
<p>大小比较问题把原数组转换成 <span class="math inline">\(b_i = |a_i
\leq \text{now}|\)</span>.</p>
<h2 id="基础模板类">-1. 基础模板类</h2>
<h4 id="快速输入输出">快速输入输出</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 快速输入输出</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> pair&lt;T1, T2&gt; &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; p.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;in, pair&lt;T1, T2&gt; &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    in &gt;&gt; p.first &gt;&gt; p.second;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;in, vector&lt;T&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        in &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> vector&lt;T&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        out &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> set&lt;T&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : a)</span><br><span class="line">        out &lt;&lt; e &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="int128">__int128</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">using</span> i128 = __int128;</span><br><span class="line"> </span><br><span class="line">std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, i128 n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::string s;</span><br><span class="line">    <span class="keyword">while</span> (n &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        s += <span class="built_in">char</span>(<span class="string">&#x27;0&#x27;</span> + n % <span class="number">10</span>);</span><br><span class="line">        n /= <span class="number">10</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::<span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">return</span> os &lt;&lt; s;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">i128 <span class="title">toi128</span><span class="params">(<span class="type">const</span> std::string &amp;s)</span> </span>&#123;</span><br><span class="line">    i128 n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> c : s) &#123;</span><br><span class="line">        n = n * <span class="number">10</span> + (c - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function">i128 <span class="title">sqrti128</span><span class="params">(i128 n)</span> </span>&#123;</span><br><span class="line">    i128 lo = <span class="number">0</span>, hi = <span class="number">1E16</span>;</span><br><span class="line">    <span class="keyword">while</span> (lo &lt; hi) &#123;</span><br><span class="line">        i128 x = (lo + hi + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (x * x &lt;= n) &#123;</span><br><span class="line">            lo = x;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            hi = x - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> lo;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">i128 <span class="title">gcd</span><span class="params">(i128 a, i128 b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        a %= b;</span><br><span class="line">        std::<span class="built_in">swap</span>(a, b);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="大整数">大整数</h4>
<p>数字转字符串: <code>s = to_string(n)</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">BigInt</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; d; <span class="comment">// 逆序数位</span></span><br><span class="line">    <span class="type">bool</span> neg;      <span class="comment">// 正负</span></span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> BASE = <span class="number">1000000000</span>;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">int</span> WIDTH = <span class="number">9</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">trim</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (!d.<span class="built_in">empty</span>() &amp;&amp; d.<span class="built_in">back</span>() == <span class="number">0</span>) d.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="keyword">if</span> (d.<span class="built_in">empty</span>()) neg = <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">BigInt</span>() : <span class="built_in">neg</span>(<span class="literal">false</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">long</span> <span class="type">long</span> x) &#123; *<span class="keyword">this</span> = x; &#125;</span><br><span class="line">    <span class="built_in">BigInt</span>(<span class="type">const</span> string &amp;s) &#123; *<span class="keyword">this</span> = s; &#125;</span><br><span class="line"></span><br><span class="line">    BigInt &amp;<span class="keyword">operator</span>=(<span class="type">long</span> <span class="type">long</span> x) &#123;</span><br><span class="line">        d.<span class="built_in">clear</span>();</span><br><span class="line">        neg = x &lt; <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (neg) x = -x;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            d.<span class="built_in">push_back</span>(x % BASE);</span><br><span class="line">            x /= BASE;</span><br><span class="line">        &#125; <span class="keyword">while</span> (x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt &amp;<span class="keyword">operator</span>=(<span class="type">const</span> string &amp;s) &#123;</span><br><span class="line">        d.<span class="built_in">clear</span>();</span><br><span class="line">        neg = <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (s[<span class="number">0</span>] == <span class="string">&#x27;-&#x27;</span>) neg = <span class="literal">true</span>, i++;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = s.<span class="built_in">size</span>() - <span class="number">1</span>; j &gt;= i; j -= WIDTH) &#123;</span><br><span class="line">            <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> k = <span class="built_in">max</span>(i, j - WIDTH + <span class="number">1</span>); k &lt;= j; ++k)</span><br><span class="line">                val = val * <span class="number">10</span> + (s[k] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            d.<span class="built_in">push_back</span>(val);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">trim</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt <span class="keyword">operator</span>+(<span class="type">const</span> BigInt &amp;b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (neg != b.neg) <span class="keyword">return</span> *<span class="keyword">this</span> - (-b);</span><br><span class="line">        BigInt res;</span><br><span class="line">        res.neg = neg;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; <span class="built_in">max</span>(d.<span class="built_in">size</span>(), b.d.<span class="built_in">size</span>()) || carry; ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x = carry;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; d.<span class="built_in">size</span>()) x += d[i];</span><br><span class="line">            <span class="keyword">if</span> (i &lt; b.d.<span class="built_in">size</span>()) x += b.d[i];</span><br><span class="line">            res.d.<span class="built_in">push_back</span>(x % BASE);</span><br><span class="line">            carry = x / BASE;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt <span class="keyword">operator</span>-(<span class="type">const</span> BigInt &amp;b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (neg != b.neg) <span class="keyword">return</span> *<span class="keyword">this</span> + (-b);</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>() &lt; b.<span class="built_in">abs</span>()) <span class="keyword">return</span> -(b - *<span class="keyword">this</span>);</span><br><span class="line">        BigInt res;</span><br><span class="line">        res.neg = neg;</span><br><span class="line">        <span class="type">int</span> carry = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">int</span> x = d[i] - carry;</span><br><span class="line">            <span class="keyword">if</span> (i &lt; b.d.<span class="built_in">size</span>()) x -= b.d[i];</span><br><span class="line">            carry = x &lt; <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (carry) x += BASE;</span><br><span class="line">            res.d.<span class="built_in">push_back</span>(x);</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">trim</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt <span class="keyword">operator</span>*(<span class="type">const</span> BigInt &amp;b) <span class="type">const</span> &#123;</span><br><span class="line">        BigInt res;</span><br><span class="line">        res.d.<span class="built_in">resize</span>(d.<span class="built_in">size</span>() + b.d.<span class="built_in">size</span>());</span><br><span class="line">        res.neg = neg != b.neg;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">size_t</span> i = <span class="number">0</span>; i &lt; d.<span class="built_in">size</span>(); ++i) &#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> carry = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">size_t</span> j = <span class="number">0</span>; j &lt; b.d.<span class="built_in">size</span>() || carry; ++j) &#123;</span><br><span class="line">                <span class="type">long</span> <span class="type">long</span> cur = res.d[i + j] + d[i] * <span class="number">1LL</span> * (j &lt; b.d.<span class="built_in">size</span>() ? b.d[j] : <span class="number">0</span>) + carry;</span><br><span class="line">                res.d[i + j] = cur % BASE;</span><br><span class="line">                carry = cur / BASE;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">trim</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt <span class="keyword">operator</span>/(<span class="type">const</span> BigInt &amp;b) <span class="type">const</span> &#123;</span><br><span class="line">        BigInt res, cur;</span><br><span class="line">        res.d.<span class="built_in">resize</span>(d.<span class="built_in">size</span>());</span><br><span class="line">        res.neg = neg != b.neg;</span><br><span class="line">        cur.neg = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i) &#123;</span><br><span class="line">            cur.d.<span class="built_in">insert</span>(cur.d.<span class="built_in">begin</span>(), d[i]);</span><br><span class="line">            cur.<span class="built_in">trim</span>();</span><br><span class="line">            <span class="type">int</span> x = <span class="number">0</span>, l = <span class="number">0</span>, r = BASE;</span><br><span class="line">            <span class="keyword">while</span> (l &lt;= r) &#123;</span><br><span class="line">                <span class="type">int</span> m = (l + r) / <span class="number">2</span>;</span><br><span class="line">                <span class="keyword">if</span> (b.<span class="built_in">abs</span>() * m &lt;= cur) x = m, l = m + <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">else</span> r = m - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            res.d[i] = x;</span><br><span class="line">            cur = cur - b.<span class="built_in">abs</span>() * x;</span><br><span class="line">        &#125;</span><br><span class="line">        res.<span class="built_in">trim</span>();</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt <span class="keyword">operator</span>%(<span class="type">const</span> BigInt &amp;b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> - *<span class="keyword">this</span> / b * b;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    BigInt &amp;<span class="keyword">operator</span>+=(<span class="type">const</span> BigInt &amp;b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> + b; &#125;</span><br><span class="line">    BigInt &amp;<span class="keyword">operator</span>-=(<span class="type">const</span> BigInt &amp;b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> - b; &#125;</span><br><span class="line">    BigInt &amp;<span class="keyword">operator</span>*=(<span class="type">const</span> BigInt &amp;b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> * b; &#125;</span><br><span class="line">    BigInt &amp;<span class="keyword">operator</span>/=(<span class="type">const</span> BigInt &amp;b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> / b; &#125;</span><br><span class="line">    BigInt &amp;<span class="keyword">operator</span>%=(<span class="type">const</span> BigInt &amp;b) &#123; <span class="keyword">return</span> *<span class="keyword">this</span> = *<span class="keyword">this</span> % b; &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> BigInt &amp;b) <span class="type">const</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (neg != b.neg) <span class="keyword">return</span> neg;</span><br><span class="line">        <span class="keyword">if</span> (d.<span class="built_in">size</span>() != b.d.<span class="built_in">size</span>()) <span class="keyword">return</span> d.<span class="built_in">size</span>() * (neg ? <span class="number">-1</span> : <span class="number">1</span>) &lt; b.d.<span class="built_in">size</span>() * (neg ? <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = d.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> (d[i] != b.d[i]) <span class="keyword">return</span> d[i] * (neg ? <span class="number">-1</span> : <span class="number">1</span>) &lt; b.d[i] * (neg ? <span class="number">-1</span> : <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;(<span class="type">const</span> BigInt &amp;b) <span class="type">const</span> &#123; <span class="keyword">return</span> b &lt; *<span class="keyword">this</span>; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;=(<span class="type">const</span> BigInt &amp;b) <span class="type">const</span> &#123; <span class="keyword">return</span> !(b &lt; *<span class="keyword">this</span>); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&gt;=(<span class="type">const</span> BigInt &amp;b) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> &lt; b); &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>==(<span class="type">const</span> BigInt &amp;b) <span class="type">const</span> &#123; <span class="keyword">return</span> d == b.d &amp;&amp; neg == b.neg; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>!=(<span class="type">const</span> BigInt &amp;b) <span class="type">const</span> &#123; <span class="keyword">return</span> !(*<span class="keyword">this</span> == b); &#125;</span><br><span class="line"></span><br><span class="line">    BigInt <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        BigInt res = *<span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">if</span> (!d.<span class="built_in">empty</span>()) res.neg = !neg;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">BigInt <span class="title">abs</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        BigInt res = *<span class="keyword">this</span>;</span><br><span class="line">        res.neg = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">friend</span> ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;os, <span class="type">const</span> BigInt &amp;x) &#123;</span><br><span class="line">        <span class="keyword">if</span> (x.neg) os &lt;&lt; <span class="string">&#x27;-&#x27;</span>;</span><br><span class="line">        os &lt;&lt; (x.d.<span class="built_in">empty</span>() ? <span class="number">0</span> : x.d.<span class="built_in">back</span>());</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x.d.<span class="built_in">size</span>() - <span class="number">2</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            os &lt;&lt; <span class="built_in">setw</span>(WIDTH) &lt;&lt; <span class="built_in">setfill</span>(<span class="string">&#x27;0&#x27;</span>) &lt;&lt; x.d[i];</span><br><span class="line">        <span class="keyword">return</span> os;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="z_p"><span class="math inline">\(Z_p\)</span></h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//模 p 整数环. 注意用到了 ll</span></span><br><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">class</span> T&gt;</span></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> T <span class="title">power</span><span class="params">(T a, ll b)</span> </span>&#123;</span><br><span class="line">    T res = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (; b; b /= <span class="number">2</span>, a *= a) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b % <span class="number">2</span>) &#123;</span><br><span class="line">            res *= a;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">constexpr</span> ll <span class="title">mul</span><span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = a * b - (ll)(<span class="number">1.L</span> * a * b / p) * p;</span><br><span class="line">    res %= p;</span><br><span class="line">    <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        res += p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span>&lt;ll P&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MLong</span> &#123;</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MLong</span><span class="params">()</span> : x&#123;</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MLong</span><span class="params">(ll x)</span> : x&#123;</span><span class="built_in">norm</span>(x % <span class="built_in">getMod</span>())&#125; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> ll Mod;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> ll <span class="title">getMod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (P &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> P;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">void</span> <span class="title">setMod</span><span class="params">(ll Mod_)</span> </span>&#123;</span><br><span class="line">        Mod = Mod_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> ll <span class="title">norm</span><span class="params">(ll x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x += <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="built_in">getMod</span>()) &#123;</span><br><span class="line">            x -= <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> ll <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">ll</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        MLong res;</span><br><span class="line">        res.x = <span class="built_in">norm</span>(<span class="built_in">getMod</span>() - x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> MLong <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, <span class="built_in">getMod</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong &amp;<span class="keyword">operator</span>*=(MLong rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">mul</span>(x, rhs.x, <span class="built_in">getMod</span>());</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong &amp;<span class="keyword">operator</span>+=(MLong rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong &amp;<span class="keyword">operator</span>-=(MLong rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MLong &amp;<span class="keyword">operator</span>/=(MLong rhs) &amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>*(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        MLong res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>+(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        MLong res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>-(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        MLong res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MLong <span class="keyword">operator</span>/(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        MLong res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, MLong &amp;a) &#123;</span><br><span class="line">        ll v;</span><br><span class="line">        is &gt;&gt; v;</span><br><span class="line">        a = <span class="built_in">MLong</span>(v);</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> MLong &amp;a) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; a.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>==(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() == rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(MLong lhs, MLong rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() != rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line">ll MLong&lt;<span class="number">0LL</span>&gt;::Mod = (ll)<span class="number">1E18</span> + <span class="number">9</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> P&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">MInt</span> &#123;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MInt</span><span class="params">()</span> : x&#123;</span>&#125; &#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="title">MInt</span><span class="params">(ll x)</span> : x&#123;</span><span class="built_in">norm</span>(x % <span class="built_in">getMod</span>())&#125; &#123;&#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> Mod;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">int</span> <span class="title">getMod</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (P &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> P;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> Mod;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">static</span> <span class="type">void</span> <span class="title">setMod</span><span class="params">(<span class="type">int</span> Mod_)</span> </span>&#123;</span><br><span class="line">        Mod = Mod_;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">norm</span><span class="params">(<span class="type">int</span> x)</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            x += <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="built_in">getMod</span>()) &#123;</span><br><span class="line">            x -= <span class="built_in">getMod</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> <span class="type">int</span> <span class="title">val</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">explicit</span> <span class="keyword">constexpr</span> <span class="keyword">operator</span> <span class="title">int</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>-() <span class="type">const</span> &#123;</span><br><span class="line">        MInt res;</span><br><span class="line">        res.x = <span class="built_in">norm</span>(<span class="built_in">getMod</span>() - x);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">constexpr</span> MInt <span class="title">inv</span><span class="params">()</span> <span class="type">const</span> </span>&#123;</span><br><span class="line">        <span class="built_in">assert</span>(x != <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">power</span>(*<span class="keyword">this</span>, <span class="built_in">getMod</span>() - <span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt &amp;<span class="keyword">operator</span>*=(MInt rhs) &amp; &#123;</span><br><span class="line">        x = <span class="number">1LL</span> * x * rhs.x % <span class="built_in">getMod</span>();</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt &amp;<span class="keyword">operator</span>+=(MInt rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x + rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt &amp;<span class="keyword">operator</span>-=(MInt rhs) &amp; &#123;</span><br><span class="line">        x = <span class="built_in">norm</span>(x - rhs.x);</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">constexpr</span> MInt &amp;<span class="keyword">operator</span>/=(MInt rhs) &amp; &#123;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span> *= rhs.<span class="built_in">inv</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>*(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res *= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>+(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res += rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>-(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res -= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> MInt <span class="keyword">operator</span>/(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        MInt res = lhs;</span><br><span class="line">        res /= rhs;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::istream &amp;<span class="keyword">operator</span>&gt;&gt;(std::istream &amp;is, MInt &amp;a) &#123;</span><br><span class="line">        ll v;</span><br><span class="line">        is &gt;&gt; v;</span><br><span class="line">        a = <span class="built_in">MInt</span>(v);</span><br><span class="line">        <span class="keyword">return</span> is;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> std::ostream &amp;<span class="keyword">operator</span>&lt;&lt;(std::ostream &amp;os, <span class="type">const</span> MInt &amp;a) &#123;</span><br><span class="line">        <span class="keyword">return</span> os &lt;&lt; a.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>==(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() == rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">friend</span> <span class="keyword">constexpr</span> <span class="type">bool</span> <span class="keyword">operator</span>!=(MInt lhs, MInt rhs) &#123;</span><br><span class="line">        <span class="keyword">return</span> lhs.<span class="built_in">val</span>() != rhs.<span class="built_in">val</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// template&lt;&gt;</span></span><br><span class="line"><span class="comment">// int MInt&lt;0&gt;::Mod = 998244353;</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="type">int</span> V, <span class="type">int</span> P&gt;</span><br><span class="line"><span class="keyword">constexpr</span> MInt&lt;P&gt; CInv = <span class="built_in">MInt</span>&lt;P&gt;(V).<span class="built_in">inv</span>();</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> ll P = <span class="number">998244353</span>;</span><br><span class="line"><span class="keyword">using</span> Z = MInt&lt;P&gt;;</span><br></pre></td></tr></table></figure>
<h2 id="基础算法">0. 基础算法</h2>
<h4 id="前缀-宏">前缀 &amp; 宏</h4>
<p>完全体</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 MB ~ 1e6 int</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// 类型转换</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> pii std::pair<span class="string">&lt;int, int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> tri std::array<span class="string">&lt;int, 3&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vi std::vector<span class="string">&lt;int&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> vt std::vector</span></span><br><span class="line"><span class="comment">// 快速位运算</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_th(x, i) ((x &gt;&gt; (i - 1)) &amp; 1)         <span class="comment">// 获得 x 的 i-th 的 bool</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_th(x, i) (x = x | (1 &lt;&lt; (i - 1)))     <span class="comment">// 强制 x 的 i-th 为 1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_th(x, i) (x = x &amp; ~(1 &lt;&lt; (i - 1)))  <span class="comment">// 强制 x 的 i-th 为 0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> make_th(x, i, v) (x = x + (v &lt;&lt; (i - 1))) <span class="comment">// 给 x 加 v * 2 ^ (i-1)</span></span></span><br><span class="line"><span class="comment">// 快速打印</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) std::cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug2(x, y) std::cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; #y &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug3(x, y, z) std::cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; #y &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; #z &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; z &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> yes std::cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> no std::cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 快速输入输出</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> pair&lt;T1, T2&gt; &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    out &lt;&lt; p.first &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; p.second &lt;&lt; <span class="string">&quot;   &quot;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;in, pair&lt;T1, T2&gt; &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">    in &gt;&gt; p.first &gt;&gt; p.second;</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">istream &amp;<span class="keyword">operator</span>&gt;&gt;(istream &amp;in, vector&lt;T&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        in &gt;&gt; a[i];</span><br><span class="line">    <span class="keyword">return</span> in;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> vector&lt;T&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; a.<span class="built_in">size</span>(); ++i)</span><br><span class="line">        out &lt;&lt; a[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">ostream &amp;<span class="keyword">operator</span>&lt;&lt;(ostream &amp;out, <span class="type">const</span> set&lt;T&gt; &amp;a)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : a)</span><br><span class="line">        out &lt;&lt; e &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> out;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上面别动</span></span><br><span class="line"><span class="comment">// #define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>((<span class="type">double</span>)<span class="number">-1.0</span>);</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="comment">// using i128 = __int128;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Mikasa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        <span class="built_in">Mikasa</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>简化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 1 MB ~ 1e6 int</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="comment">// #define int long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> double long double</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ll long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ull unsigned long long</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> get_th(x, i) ((x &gt;&gt; (i - 1)) &amp; 1)         <span class="comment">// 获得 x 的 i-th 的 bool</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug(x) std::cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug2(x, y) std::cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; #y &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; y &lt;&lt; endl;</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> debug3(x, y, z) std::cout &lt;&lt; #x &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; x &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; #y &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; y &lt;&lt; <span class="string">&quot;   &quot;</span> &lt;&lt; #z &lt;&lt; <span class="string">&quot; = &quot;</span> &lt;&lt; z &lt;&lt; endl;</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="comment">// #define endl &#x27;\n&#x27;</span></span><br><span class="line"><span class="type">const</span> ll INF = <span class="number">0x3f3f3f3f3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> inf = <span class="number">0x3f3f3f3f</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">int</span> maxn = <span class="number">1e5</span> + <span class="number">10</span>;</span><br><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Mikasa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">signed</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ios::<span class="built_in">sync_with_stdio</span>(<span class="literal">false</span>);</span><br><span class="line">    cin.<span class="built_in">tie</span>(<span class="number">0</span>), cout.<span class="built_in">tie</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="type">int</span> t = <span class="number">1</span>;</span><br><span class="line">    cin &gt;&gt; t;</span><br><span class="line">    <span class="keyword">while</span> (t--)</span><br><span class="line">        <span class="built_in">Mikasa</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="排序">排序</h4>
<p><strong>快速排序</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">quick_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span>(l &gt;= r)	<span class="keyword">return</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="type">int</span> x = a[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line">	<span class="keyword">while</span>(i &lt; j)</span><br><span class="line">	&#123;</span><br><span class="line">		<span class="keyword">do</span> ++ i ; <span class="keyword">while</span>(a[i] &lt; x);</span><br><span class="line">		<span class="keyword">do</span> -- j ; <span class="keyword">while</span>(a[j] &gt; x);</span><br><span class="line">        <span class="keyword">if</span>(i &lt; j)	<span class="built_in">swap</span>(a[i], a[j]);</span><br><span class="line">	&#125;</span><br><span class="line">    </span><br><span class="line">	<span class="built_in">quick_sort</span>(a, l, j);</span><br><span class="line">	<span class="built_in">quick_sort</span>(a, j + <span class="number">1</span>, r);</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>归并排序</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge_sort</span><span class="params">(<span class="type">int</span> a[], <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(l &gt;= r)  <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">merge_sort</span>(a, l, mid);</span><br><span class="line">    <span class="built_in">merge_sort</span>(a, mid + <span class="number">1</span>, r);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid &amp;&amp; j &lt;= r)</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; a[j]) tmp[k ++] = a[i ++];</span><br><span class="line">        <span class="keyword">else</span>	tmp[k ++] = a[j ++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(i &lt;= mid) tmp[k ++] = a[i ++];</span><br><span class="line">    <span class="keyword">while</span>(j &lt;= r)   tmp[k ++] = a[j ++];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i = l, j = <span class="number">0</span>; i &lt;= r; i ++, j ++)   </span><br><span class="line">        a[i] = tmp[j];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="二分-三分">二分 / 三分</h4>
<p><strong>整数二分</strong></p>
<p>先按题意分为两个区间（记为 A 区间和 B 区间）</p>
<p><strong>A区间的右端点</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A区域的右端点。区间[l, r]被划分成[l, mid - 1]和[mid, r]时使用：</span></span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mid = l + r + <span class="number">1</span> &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	(mid belong A)? l = mid: r = mid - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//return l;</span></span><br></pre></td></tr></table></figure>
<p><strong>B区间的左端点</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// B区域的左端点。区间[l, r]被划分成[l, mid]和[mid + 1, r]时使用：</span></span><br><span class="line"><span class="keyword">while</span> (l &lt; r)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">	(mid belong A)? l = mid + <span class="number">1</span>: r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//return l;</span></span><br></pre></td></tr></table></figure>
<p><strong>lower/upper_bound</strong></p>
<p><code>lower_bound</code> 返回第一个大于等于 value 的地址</p>
<p><code>upper_bound</code> 返回第一个大于 value 的地址</p>
<p><strong>浮点数二分</strong></p>
<p>一样分为 A 区间和 B 区间</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// eps 表示精度，取决于题目对精度的要求，通常要比题目要求高两个数量级</span></span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-6</span>;   </span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> (r - l &gt; eps)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">	<span class="keyword">if</span> (mid belong A) l = mid;</span><br><span class="line">	<span class="keyword">else</span> r = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//return l;</span></span><br></pre></td></tr></table></figure>
<p><strong>三分</strong></p>
<p>本质还是二分，只是判断区间 A、B 时用了两个参数</p>
<p><strong>浮点数三分</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(r - l &gt; eps)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> k = (r - l) / <span class="number">3.0</span>;</span><br><span class="line">    <span class="type">double</span> mid1 = l + k, mid2 = r - k;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">f</span>(mid1) &gt; <span class="built_in">f</span>(mid2) ) r = mid2;</span><br><span class="line">    <span class="keyword">else</span>    l = mid1;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>实数三分</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(r - l &gt; <span class="number">2</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> mid1 = l + (r - l) / <span class="number">3</span>;</span><br><span class="line">    <span class="type">int</span> mid2 = r - (r - l) / <span class="number">3</span>;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">check</span>(mid1, mid2) )</span><br><span class="line">        move r;</span><br><span class="line">     <span class="keyword">else</span></span><br><span class="line">        move l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="前缀和-差分">前缀和 / 差分</h4>
<p>前缀和与差分可以看做逆运算，但是处理手段略有不同</p>
<p><strong>前缀和</strong></p>
<p>容斥原理</p>
<p><span class="math inline">\(O(1)\)</span>完成静态数组的区间查询</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//一维前缀和</span></span><br><span class="line">S[i]  = s[i - <span class="number">1</span>] + a[i];<span class="comment">//= a[1] + a[2] + ... + a[i]</span></span><br><span class="line">a[l] + ... + a[r] = S[r] - S[l - <span class="number">1</span>]</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二维前缀和</span></span><br><span class="line"><span class="comment">//S[i, j] = 第i行j列格子左上部分所有元素的和; 以(x1, y1)为左上角，(x2, y2)为右下角的子矩阵的和为：</span></span><br><span class="line">s[i][j] = s[i][j - <span class="number">1</span>] + s[i + <span class="number">1</span>][j] - s[i <span class="number">-1</span>][j <span class="number">-1</span>] + a[i][j];</span><br><span class="line">S[x2, y2] - S[x1 - <span class="number">1</span>, y2] - S[x2, y1 - <span class="number">1</span>] + S[x1 - <span class="number">1</span>, y1 - <span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p><strong>差分</strong></p>
<p><span class="math inline">\(O(1)\)</span>完成动态数组的区间修改</p>
<p>一维差分 —— 给区间[l, r]中的每个数加上c:</p>
<p><code>d[l] += c, d[r + 1] -= c</code></p>
<p>二维差分 —— 差分矩阵，给以(x1, y1)为左上角，(x2,
y2)为右下角的子矩阵中的所有元素加上c:</p>
<p><code>d[x1, y1] += c, d[x2 + 1, y1] -= c, d[x1, y2 + 1] -= c, d[x2 + 1, y2 + 1] += c</code></p>
<h4 id="离散化">离散化</h4>
<p>三步法: 排序, 去重, lower_bound (非卡常用 <code>map</code> )</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;	cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line">    copy[i] = a[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">sort</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>);</span><br><span class="line"><span class="comment">//sort(copy + 1, copy + n + 1);</span></span><br><span class="line"><span class="type">int</span> size = <span class="built_in">unique</span>(a + <span class="number">1</span>, a + n + <span class="number">1</span>) - a - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; i ++) </span><br><span class="line">&#123;</span><br><span class="line">    ls[i] = <span class="built_in">lower_bound</span>(a + <span class="number">1</span>, a + size + <span class="number">1</span>, copy[i]) - a;<span class="comment">//即ls为copy离散化后对应的下标</span></span><br><span class="line">    cout&lt;&lt;ls[i]&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> v[MAXN];<span class="comment">//原数据</span></span><br><span class="line"><span class="type">int</span> a[MAXN], s[MAXN];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        cin&gt;&gt;v[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">        s[i] = a[i] + s[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    v[n + <span class="number">1</span>] = INF;</span><br><span class="line">    s[n + <span class="number">1</span>] = s[n];</span><br><span class="line">    cin&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= q; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> lv, rv;</span><br><span class="line">        cin&gt;&gt;lv&gt;&gt;rv;</span><br><span class="line">        <span class="type">int</span> l = (<span class="built_in">lower_bound</span>(v, v + n + <span class="number">1</span>, lv) - v);</span><br><span class="line">        <span class="type">int</span> r = (<span class="built_in">upper_bound</span>(v, v + n + <span class="number">1</span>, rv) - v - <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        cout&lt;&lt;s[r] - s[l - <span class="number">1</span>]&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="位运算">位运算</h4>
<p><code>^</code> 异或 <code>&amp;</code> 和 <code>|</code> 或</p>
<p><code>lowbit(i)</code> or <code>i &amp; -i</code> 返回 i 的最后一位
1</p>
<p><code>n &gt;&gt; k &amp; 1</code> 求 n 的第 k 位数字</p>
<p><code>x | ( 1 &lt;&lt; k )</code> 将 x 第 k 位变为1</p>
<p><code>x ^ ( 1 &lt;&lt; k )</code> 将 x 第 k 位取反</p>
<p><code>x &amp; ( x - 1 )</code> 将 x 最右边的 1 置为 0 (去掉最右边的 1
)</p>
<p><code>x | ( x + 1 )</code> 将 x 最右边的 0 置为 1</p>
<p><code>x &amp; 1</code> 判断奇偶性：真为奇，假为偶</p>
<p>快速位运算: <a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/583866513">C/C++
__builtin 超实用位运算函数总结 - 知乎</a></p>
<p><strong>结论</strong></p>
<p><span class="math inline">\(a\oplus b = c\Leftrightarrow a\oplus c =
b\Leftrightarrow b\oplus c = a\)</span></p>
<p>求异或不等式<span class="math inline">\(a\oplus x &gt; b\)</span>,
见<em>构造专题</em></p>
<p><span class="math inline">\(|a - b|\leq a\oplus b \leq a + b\leq
2\max{(a, b)}\)</span>, 可以想想什么时候等式成立</p>
<p><span class="math inline">\(0\leq a\&amp;b\leq 2\min{(a, b)}\leq a +
b\)</span></p>
<p><span class="math inline">\(a\oplus b = a|b - a\&amp; b\)</span></p>
<p><strong>异或不能保持序关系!</strong> 也就是说 <span
class="math inline">\(a\leq b \Leftrightarrow a\oplus c\leq b\oplus
c\)</span> 是错的!</p>
<h4 id="双指针">双指针</h4>
<p><strong>尺取法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//check: 是否满足要求</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(j &lt; n &amp;&amp; !<span class="built_in">check</span>(now))</span><br><span class="line">    &#123;</span><br><span class="line">        ++ j;</span><br><span class="line">        <span class="comment">//...    </span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="comment">//deal i</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1638">P1638 逛画展</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//本题中用 cnt 来判断是否完成所有作品, 避免了遍历数组t, 值得学习</span></span><br><span class="line"><span class="type">int</span> a[maxn], t[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> l, r, mina = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(j &lt; n &amp;&amp; cnt &lt; m)</span><br><span class="line">        &#123;</span><br><span class="line">            ++ j;</span><br><span class="line">            <span class="keyword">if</span>(t[ a[j] ] == <span class="number">0</span>)</span><br><span class="line">                cnt ++;</span><br><span class="line">            t[ a[j] ] ++;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(cnt &gt;= m &amp;&amp; j - i + <span class="number">1</span> &lt; mina)</span><br><span class="line">        &#123;</span><br><span class="line">            mina = j - i + <span class="number">1</span>;</span><br><span class="line">            l = i, r = j;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(t[ a[i] ] == <span class="number">1</span>)</span><br><span class="line">            cnt --;</span><br><span class="line">        t[ a[i] ] --;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;l&lt;&lt;<span class="string">&#x27; &#x27;</span>&lt;&lt;r&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>环的非负前缀和子段</strong></p>
<p>给一个长 n 的环, 找一个点, 使得展开得到数组的前缀和均为非负</p>
<h4 id="搜索">搜索</h4>
<p><strong>DFS</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">bool</span> done[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(<span class="type">int</span> cnt, <span class="type">int</span> k)</span><span class="comment">//以及其它参数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//结束条件</span></span><br><span class="line">	<span class="comment">//剪枝</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(done[i])	<span class="keyword">continue</span>;</span><br><span class="line">        done[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(cnt + <span class="number">1</span>, i);</span><br><span class="line">        done[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>BFS</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line"></span><br><span class="line">done[<span class="number">1</span>] = <span class="number">1</span>; <span class="comment">// 表示1号点已经被遍历过</span></span><br><span class="line">q.<span class="built_in">push</span>(<span class="number">1</span>);</span><br><span class="line"><span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> t = q.<span class="built_in">front</span>();</span><br><span class="line">    q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//t -&gt; j</span></span><br><span class="line">    <span class="comment">//done[j] = 1;</span></span><br><span class="line">    <span class="comment">//q.push(j);</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>剪枝</strong></p>
<p>记忆化: 记录当前状态, 之后可直接调用</p>
<p>最优性: 若当前答案已不是最优, 结束</p>
<p>可行性: 若当前不可行, 结束</p>
<p><strong>Trick</strong></p>
<p><code>next_permutation</code></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">f</span>(n); ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">next_permutation</span>(p.<span class="built_in">begin</span>() + <span class="number">1</span>, p.<span class="built_in">end</span>());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="动态规划">1. 动态规划</h2>
<p>关于初始化: 初始化不一定要满足定义, 而是要保证正确性.</p>
<h3 id="线性-dp">1.1 线性 DP</h3>
<p><strong>背包问题</strong></p>
<p><strong>01背包问题</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1048">P1048 采药</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 105</span></span><br><span class="line"><span class="type">int</span> dp[maxn][<span class="number">1005</span>],t[maxn],v[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= M; ++ i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= T; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= t[i])</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i<span class="number">-1</span>][j],dp[i<span class="number">-1</span>][j - t[i]] + v[i])</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = dp[i<span class="number">-1</span>][j];</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>01背包问题（变式）</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1049">P1049
装箱问题</a></p>
<p><strong>注意到 $ w_i=v_i$</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAXN 35<span class="comment">//数组大小</span></span></span><br><span class="line"><span class="type">int</span> dp[MAXN][<span class="number">20005</span>], v[MAXN];</span><br><span class="line"></span><br><span class="line">dp[<span class="number">0</span>][V] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= V; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= v[i])</span><br><span class="line">            dp[i][j] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>][j], dp[i - <span class="number">1</span>][j - v[i]] + v[i]);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="type">int</span> res = -INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= V; ++ j)</span><br><span class="line">    res = <span class="built_in">max</span>(dp[n][j], res);</span><br><span class="line">cout&lt;&lt; V - res &lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p><strong>完全背包问题</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1616">P1616
疯狂的采药</a></p>
<p>时间复杂度<span class="math inline">\(o(n^3)\)</span>（来自 oi
wiki）</p>
<p>学长给出的时间优化：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = a[i]; j &lt;= t; ++ j)</span><br><span class="line">        dp[j] = <span class="built_in">max</span>(dp[j], dp[j - a[i]] + b[i]);</span><br></pre></td></tr></table></figure>
<p>时间复杂度<span class="math inline">\(o(n^2)\)</span>.</p>
<p><strong>可选性背包</strong></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1974/problem/E">Problem - E -
Codeforces</a></p>
<p><strong>未AC</strong></p>
<p>我想到的是反悔贪心（边走边拿，能拿下就把拿到的记录到某个数据结构 A
中；拿不下就反悔，从 A 中用 01背包选反悔的）</p>
<p>实际上就是给状态转移加个判断，满足就可以转移，反之则不能。</p>
<p>对于该题，还要注意：考虑到价值和体积的大小，<strong>背包的第二参量应为价值</strong>，即
<span class="math inline">\(dp_{ij}\)</span> 表示"当遍历到第 i
个物品、得到 j 价值时，花费体积的最小值"</p>
<p>故有： <span class="math display">\[
if(dp[i - 1][j] + w[i] &lt;= (i - 1) * x )\\
dp[i][j] = \min(dp[i - 1][j], dp[i - 1][j + v[i]] + w[i])\\
otherwise\\
dp[i][j] = dp[i - 1][j]\\
\]</span></p>
<p><strong>改变参量的背包</strong></p>
<p><strong>路径 DP</strong></p>
<p><strong>数字三角形</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1216">P1216 数字三角形
Number Triangles</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> maxn 105</span></span><br><span class="line"><span class="type">int</span> a[maxn][maxn],dp[maxn][maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        dp[n][i] = a[n][i];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= i; ++ j)</span><br><span class="line">        dp[i][j] = <span class="built_in">max</span>(a[i][j] + dp[i + <span class="number">1</span>][j], a[i][j] + dp[i + <span class="number">1</span>][j + <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<p><strong>等跨度路线（特定点不可取）</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1002">P1002 过河卒</a></p>
<p>1、抵消 -1 标记</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[MAXN][MAXN];</span><br><span class="line"><span class="type">int</span> dx[] = &#123;<span class="number">-2</span>, <span class="number">-2</span>, <span class="number">-1</span>, <span class="number">-1</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">2</span>, <span class="number">0</span>&#125;;</span><br><span class="line"><span class="type">int</span> dy[] = &#123;<span class="number">1</span>, <span class="number">-1</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">2</span>, <span class="number">-2</span>, <span class="number">1</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(x + dx[i] &gt;= <span class="number">0</span> &amp;&amp; y + dy[i] &gt;= <span class="number">0</span>)</span><br><span class="line">    a[x + dx[i]][y + dy[i]] = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i][<span class="number">0</span>] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    a[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[<span class="number">0</span>][j] == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    a[<span class="number">0</span>][j] = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i][j] != <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            a[i][j] = a[i - <span class="number">1</span>][j] + a[i][j - <span class="number">1</span>];</span><br><span class="line">            <span class="comment">//抵消-1</span></span><br><span class="line">            <span class="keyword">if</span>(a[i - <span class="number">1</span>][j] == <span class="number">-1</span>)</span><br><span class="line">                ++ a[i][j];</span><br><span class="line">            <span class="keyword">if</span>(a[i][j - <span class="number">1</span>] == <span class="number">-1</span>)</span><br><span class="line">                ++ a[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            a[i][j] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; a[n][m];</span><br></pre></td></tr></table></figure>
<p><strong>不等跨度的选路</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1164">P1164
小A点菜</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">    dp[i][<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++ j)</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= a[i])</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - a[i]] + dp[i - <span class="number">1</span>][j];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br></pre></td></tr></table></figure>
<h3 id="区间-dp">1.2 区间 DP</h3>
<p><strong>子序列 / 子串问题</strong></p>
<p><strong>最长单调子序列 <span class="math inline">\(O(n^2)\)</span>
解法</strong></p>
<p>给出模板： <span class="math display">\[
dp[i] = \text{choose}_{1 \leq j &lt; i}(\text{change}(\ dp[j]\
)),\text{if}(\text{pair}(i,j) \text{can move})
\]</span> <a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/B3637">B3637
最长上升子序列</a> <span class="math display">\[
dp[i] = max_{1 \leq j &lt; i}(dp[j] + 1),if(a[i] &gt; a[j])
\]</span></p>
<p><strong>未AC</strong></p>
<p>同下，用 <span class="math inline">\(dp[i]\)</span>
表示最后一个接的馅饼为i时，总接到的馅饼的最大值 有: <span
class="math inline">\(dp[i] = \max_{1 \leq j &lt; i}(dp[j] +
1),if(\text{dis}(i, j) &lt; \Delta \text{time})\)</span>
这个思路没啥大问题，但是题目要求刚开始时在5的位置...</p>
<p>暂时实现不了，换一种dp： <span
class="math inline">\(dp[i][j]\)</span>：第i秒位于j时，接到馅饼数的最大值
<span class="math inline">\(dp[i][j] = \max(dp[i - 1][j], dp[i - 1][j +
1], dp[i - 1][j - 1]) + \text{cake}[i][j]\)</span> 考虑到边界问题，把
<span class="math inline">\(dp[i][0]\)</span> 和 <span
class="math inline">\(dp[i][11]\)</span> 设置为-1
可用滚动数组优化，但是由于每次小循环时会读取 <span
class="math inline">\(dp[i - 1][j + 1]\)</span>(假定 j 是从1到10遍历)
那么如果直接去掉第一维，那么在第一维为 <span
class="math inline">\(i\)</span> 时更新 <span class="math inline">\(dp[j
+ 1]\)</span> 之前，已经把 <span class="math inline">\(dp[j]\)</span>
更新为 <span class="math inline">\(dp[i][j]\)</span> 了</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2285">P2285 打鼹鼠</a></p>
<p>用 x,y,t 三个参量，时间复杂度 <span
class="math inline">\(O(n^2t)\)</span>, 显然超时.
实际上给出的地鼠序列是按时间排好序的, 是“可选性最长单调子序列”</p>
<p>记 <span class="math inline">\(dp[i]\)</span> 为最后打第 i
个地鼠时，打地鼠数的最大值 <span class="math inline">\(dp[i] = \max_{1
\leq j &lt; i}(dp[j] + 1),if(\text{MHTdis}(a[i], a[j]) \leq \Delta
\text{time}(i, j) )\)</span></p>
<p><strong>曼哈顿距离</strong>：简单说就是走格子数，区别于欧氏距离</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt; i; ++ j)</span><br><span class="line">		<span class="keyword">if</span>(<span class="built_in">MHTdistance</span>(a[i], a[j]) &lt;= <span class="built_in">abs</span>(a[i].t - a[j].t))</span><br><span class="line">			dp[i] = <span class="built_in">max</span>(dp[i], dp[j] + <span class="number">1</span>);</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1874">P1874
快速求和</a></p>
<p>先预处理求出从 i 到 j 的字符串的值 <span
class="math inline">\(sum[i][j]\)</span></p>
<p>$dp[i][k] <span class="math inline">\(表示最后一个为 i、和为 k
时的最少加号数\)</span>dp[i][k] = min_{1 j i}(dp[j][k - sum[j][i]] +
1)$</p>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1260">Problem -
1260 (hdu.edu.cn)</a> <span class="math display">\[
给出数列a，b，分别表示i的权重，i和i+1两个人一起算的权重，求出所有人权重的最小值\\
记dp[i]为i结尾时，权重的集合，取其最小值\\
dp[i] = min(dp[i - 1] + a[i], dp[i - 2] + b[i - 1])\\
\]</span></p>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1087">Problem -
1087 (hdu.edu.cn)</a> <span class="math display">\[
给出数列a，求和最大的递增子序列\\
记dp[i]为最后一个选i时的最大和\\
dp[i] = max_{1 \leq j &lt; i}(dp[j] + a[i]),if(a[i]&gt;a[j])
\]</span></p>
<p><a target="_blank" rel="noopener" href="https://acm.hdu.edu.cn/showproblem.php?pid=1069">Problem -
1069 (hdu.edu.cn)</a></p>
<p><strong>未AC</strong> <span class="math display">\[
先按长排好序，再dp宽\\
dp[i] = max_{1 \leq j &lt; i}(dp[j] + h[i]),if(b[i] &gt; b[j])\\
——然后连案例都过不去（\\
题目中三维是可以转动而更改的，并且每种积木都是无限量供应\\
如果我们把每个积木的选择情况全排列出来，每个积木有3！=6种，而且还是无限供应\\
看似很麻烦，但实际上高相同的积木最多只用一次，所以只要把高不同的情况列出来就可以，每个都有3种。\\
然后对长进行降序排序，对宽进行dp，方程不变，但是转移条件改为：\\
a[i] &gt; a[j] \&amp; b[i] &gt; b[j](有a是因为sort不去重\\
另外i的范围扩大到（1，3*n）\\
案例过去了，但是 wa 了
\]</span></p>
<p><strong>最长公共子序列<span
class="math inline">\(O(n^2)\)</span>解法</strong></p>
<p>记 <span class="math inline">\(dp[i][j]\)</span> 为: s1最后一位为
s1[i]，s2最后一位为 s2[j] 时，公共子序列长度最大值 <span
class="math display">\[
dp[i][j] =
\left\{
\begin{array}{}
dp[i - 1][j - 1] + 1, if(s1[i] = s2[j])\\
max(dp[i - 1][j], dp[i][j - 1]),otherwise\\
\end{array}
\right.
\]</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= size1; ++ i)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= size2; ++ j)</span><br><span class="line">		dp[i][j] = (s1[i - <span class="number">1</span>] == s2[j - <span class="number">1</span>]) ? dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span> : <span class="built_in">max</span>(&#123;dp[i][j], dp[i - <span class="number">1</span>][j], dp[i][j - <span class="number">1</span>]&#125;);</span><br></pre></td></tr></table></figure>
<p><strong>最长公共子串<span
class="math inline">\(O(n^2)\)</span>解法</strong> <span
class="math display">\[
记dp[i][j]为：\\
以s1[i]，s2[j]结尾时，公共子串最大长度\\
dp[i][j] = \begin{cases}
dp[i - 1][j - 1] + 1, if(s1[i] = s2[j])\\
0, otherwise
\end{cases}
\]</span></p>
<p><strong>最长的 a 子序列且是 b 子串</strong></p>
<p>想到这样一个问题： <span class="math display">\[
已知字符串a，b，求len(s)_{max}\\
s既是a的子序列，又是b的子串\\
\]</span></p>
<p><span class="math display">\[
记dp[i][j]为:\\
以a最后一位是a[i]，b最后一位为b[j]时，公共子序列长度最大值\\
dp[i][j] =
\left\{
\begin{array}{}
dp[i - 1][j - 1] + 1, if(a[i] = b[j])\\
dp[i - 1][j],otherwise\\
\end{array}
\right.
\]</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">	<span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>;  j &lt;= m; ++ j)</span><br><span class="line">        <span class="keyword">if</span>(a[i - <span class="number">1</span>] == b[j - <span class="number">1</span>])</span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">            dp[i][j] = dp[i - <span class="number">1</span>][j];</span><br></pre></td></tr></table></figure>
<p><strong>其他区间 DP</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4933">P4933 大师</a> <span
class="math display">\[
给定数列a, 求等差子序列的个数(mod\ p).注意单个元素也算等差子序列\\
其中n\leq1e3, max(a)\leq1e4.
\]</span></p>
<p><span class="math display">\[
dp[i][a_i - a_j] 表示以 i 结尾, 公差为 a_i - a_j 的最大等差数列数.\\
dp[i][a_i - a_j] = dp[i][a_i - a_j] + dp[j][a_i - a_j] + 1\ (j &lt; i)
\]</span></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1874">P1874
快速求和</a></p>
<p>给定一个数字字符串 s 和 n (<span class="math inline">\(|s|\leq 40, n
\leq 10^5\)</span>), 问: 在 s 中塞入最少多少个加号,
能使得表达式值为n.</p>
<p>(可行性剪枝 + 最优性剪枝 + 卡时的 DFS 居然草过去了…)</p>
<h3 id="特殊-dp">1.3 特殊 DP</h3>
<p><strong>状态压缩 DP</strong></p>
<p>很经典的 TSP 问题: 从 <span class="math inline">\(O(n\cdot
n!)\)</span> 优化至 <span class="math inline">\(O(n^2 2^n)\)</span>
(可解性从 <span class="math inline">\(n\leq 10\)</span> 升至 <span
class="math inline">\(n\leq 20\)</span>) <span
class="math inline">\(dp[S][j]\)</span> 为: 在集合 S 中,
从起点出发终点为 j 的路径最短值. 则有: <span
class="math inline">\(dp[S][j] = \min(dp[S - j][k] + dis(k, j))(k\in S -
j)\)</span></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1433">P1433 吃奶酪</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">double</span> dis[maxn][maxn];</span><br><span class="line"><span class="type">double</span> x[maxn], y[maxn];</span><br><span class="line"><span class="type">double</span> dp[<span class="number">1</span> &lt;&lt; <span class="number">20</span>][maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">getdis</span><span class="params">(<span class="type">int</span> v, <span class="type">int</span> w)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sqrt</span>((x[v] - x[w]) * (x[v] - x[w]) + (y[v] - y[w]) * (y[v] - y[w]));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n;  cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        cin&gt;&gt;x[i]&gt;&gt;y[i];</span><br><span class="line">    x[<span class="number">0</span>] = y[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= n; ++ j)</span><br><span class="line">            dis[i][j] = <span class="built_in">getdis</span>(i, j);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">1</span>; s &lt; ( <span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span> ; j &lt;= n; ++ j)</span><br><span class="line">            dp[s][j] = INF;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">        dp[<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)][j] = dis[j][<span class="number">0</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//枚举所有状态</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> s = <span class="number">1</span>; s &lt; (<span class="number">1</span> &lt;&lt; n); ++ s)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">            <span class="keyword">if</span>((s &gt;&gt; (j - <span class="number">1</span>) ) &amp; <span class="number">1</span>) <span class="comment">//if j in s</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">1</span>; k &lt;= n; ++ k)   </span><br><span class="line">                    <span class="keyword">if</span>((s - (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)) ) &gt;&gt; (k <span class="number">-1</span>) &amp; <span class="number">1</span>) <span class="comment">//if k in s - j</span></span><br><span class="line">                        dp[s][j] = <span class="built_in">min</span>(dp[s][j], dp[s ^ (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][k] + dis[k][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="type">double</span> ans = INF;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++ j)</span><br><span class="line">        ans = <span class="built_in">min</span>(ans, dp[(<span class="number">1</span> &lt;&lt; n) - <span class="number">1</span>][j]);</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, ans);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>未分类</strong></p>
<p><strong>最大的连续子段和</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1115">P1115
最大子段和</a></p>
<p>自己做的时候只想出前缀和+穷举，复杂度<span class="math inline">\(O (
n ^ 2 )\)</span>.</p>
<p>不要思维定式地用前缀和，nor
潜意识地认为子段和就比单项大。DP的关键在于递推式，所以重要的是<strong>找到局部的递推过程</strong>！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + s[i], s[i]);</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P2679">P2679 子串</a></p>
<p><span class="math inline">\(dp_{i, j, k}\)</span>: 以 s[i], t[j]
结尾, 已经使用 k 次的方案数</p>
<p><a
target="_blank" rel="noopener" href="https://codeforces.com/group/5YwhNALdOq/contest/1783/problem/D">Problem
- D - Codeforces</a></p>
<p><strong>题意</strong></p>
<p>$ i $ 从 2 到 n - 1, 每次可以使 <span class="math inline">\(a_{i - 1}
- a_i, a_{i + 1} + a_i\)</span> 或者 $ a_{i - 1} + a_i, a_{i + 1} - a_i$
, 问数组最后有多少种可能的情况?</p>
<p><strong>解</strong></p>
<p>$ dp[ i ][ j ]$: 遍历到 <span class="math inline">\(i\)</span>, 以
<span class="math inline">\(j\)</span> 结尾时的数量.</p>
<p>由于操作是前面影响后面的, 所以用<strong>刷表法</strong>.
由递推关系可得:</p>
<p>当 <span class="math inline">\(j \neq 0\)</span> 时: <span
class="math display">\[
\begin{cases}
dp[i + 1][a_{i + 1} + j] += dp[i][j]\\
dp[i + 1][a_{i + 1} - j] += dp[i][j]\\
\end{cases}
\]</span> 当 <span class="math inline">\(j = 0\)</span> 时: <span
class="math display">\[
dp[i + 1][a_{i + 1}] += dp[i][0]
\]</span> 初始化: <span class="math inline">\(dp[2][a_2] = 1\)</span>.
(因为 <span class="math inline">\(a_1\)</span> 是不参与操作的)</p>
<p>时空复杂度 <span class="math inline">\(O(n^2a)\)</span></p>
<p>细节: 防负加偏移, 滚动数组优化, 按题意取模</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> a[maxn];</span><br><span class="line"><span class="type">int</span> dp[<span class="number">5</span>][maxn * maxn * <span class="number">3</span>];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, s = <span class="number">0</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        s += a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; ++ i)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt;= s * <span class="number">3</span>; ++ j)</span><br><span class="line">            dp[i][j] = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">bool</span> now = <span class="number">0</span>;</span><br><span class="line">    dp[now][a[<span class="number">2</span>] + s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> k = <span class="number">0</span>; k &lt;= s * <span class="number">3</span>; ++ k)</span><br><span class="line">            dp[!now][k] = <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = -s; j &lt;= s; ++ j)<span class="comment">//j 表示最后一个值  </span></span><br><span class="line">            <span class="keyword">if</span>(j)</span><br><span class="line">                dp[!now][a[i + <span class="number">1</span>] + j + s] += dp[now][j + s] % p, dp[!now][a[i + <span class="number">1</span>] - j + s] += dp[now][j + s] % p; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[!now][a[i + <span class="number">1</span>] + s] += dp[now][j + s] % p;</span><br><span class="line">        </span><br><span class="line">        now = !now;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = -s; j &lt;= s; ++ j)</span><br><span class="line">        ans += dp[now][j + s] % p;</span><br><span class="line">    cout &lt;&lt; ans % p &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="dp-优化">1.? DP 优化</h3>
<p><strong>数据结构优化</strong></p>
<p><strong>单调队列</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1725">P1725 琪露诺</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, l, r;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;l&gt;&gt;r;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt;= n; ++ i)</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; l; ++ i)</span><br><span class="line">        dp[i] = -INF;<span class="comment">//注意这一步, 防止出现不可能的路径</span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!q.<span class="built_in">empty</span> () &amp;&amp; q.<span class="built_in">front</span> () &lt; i - r)</span><br><span class="line">            q.<span class="built_in">pop_front</span> ();</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span> () &amp;&amp; dp[q.<span class="built_in">back</span> ()] &lt; dp[i - l])</span><br><span class="line">            q.<span class="built_in">pop_back</span> ();</span><br><span class="line">        q.<span class="built_in">push_back</span> ( i - l );</span><br><span class="line">        dp[i] = dp[q.<span class="built_in">front</span> ()] + a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> ans = -inf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = n - (r - l) - <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, dp[i]);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>利用性质减少枚举</strong></p>
<p>给一个长度为 <span class="math inline">\(n\)</span> 的数组 <span
class="math inline">\(a\)</span>
。当且仅当以下条件符合时，子序列才是好序列：</p>
<ul>
<li>其长度至少为 <span class="math inline">\(2\)</span> ；</li>
<li>两个连续元素之间的绝对差是质数。</li>
</ul>
<p>计算 <span class="math inline">\(a\)</span>
的良好子序列的个数。将其输出为 <span
class="math inline">\(998244353\)</span> 的模。<span
class="math inline">\(2 \le n \le 10^5\)</span> , <span
class="math inline">\(1 \le a_i \le 10^4\)</span></p>
<p>容易想到 <span class="math inline">\(O(n^2\log(\pi(a))\)</span> 解法,
但是注意到第二层循环可以枚举所有质数, 优化至 <span
class="math inline">\(O(n\pi(a))\)</span>.</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4310">P4310
绝世好题</a></p>
<p>利用按位取和的性质来做. 每次都要有一位共同的 1 才能转移,
所以转移方程为:</p>
<p><span class="math display">\[
dp[j] =  \max(dp[k]) + 1, ( 2^j\in a[i]\and \exist 2^k\in a[i])
\]</span></p>
<h2 id="贪心-构造">2. 贪心 / 构造</h2>
<h3 id="构造">构造</h3>
<p>构造几乎离不开贪心.</p>
<p>构造的一种方法: 先找一个尽可能紧的上下界, 然后根据上下界来构造</p>
<p>例如先证明 <span class="math inline">\(ans\leq n\)</span>,
然后以此为依据构造出一种 <span class="math inline">\(ans = n\)</span>
的解, 从而证明这就是正解.</p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2065/problem/E">Problem - E -
Codeforces</a></p>
<p>给定 n, m, k, 构造一个由 n 个 0, m 个 1 构成的字符串. 使得:
所有子串的 <span class="math inline">\(|cnt_1 - cnt_0| \leq
k\)</span></p>
<p><strong>题解</strong></p>
<p>容易给出上下限: <span class="math inline">\(|n - m|\leq k\leq \max(n,
m)\)</span>.</p>
<p>对于在这个范围内的 k, 可以给出一种构造: 不妨假设 <span
class="math inline">\(n\geq m\)</span>, 那么先输出 k 个 1, 然后交替输出
01, 最后输出剩下的 0 or 1. 结果必然符合要求, 故而上述范围是充要条件.</p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1667/C">Problem -
1667C - Codeforces</a></p>
<p><strong>题意</strong></p>
<p>半皇后能攻击同行、同列和同<strong>主对角线</strong>上的单元格。也就是说,
她比皇后少了左下和右上的选择.</p>
<p>给定 n, 在 n * n 的棋盘上至少放多少个半皇后,
使得所有点都能被直接攻击到? 构造一个答案.</p>
<p><strong>解法</strong></p>
<p>棋子数量的<strong>理论下界</strong>：</p>
<p>假设放了 <span class="math inline">\(k\)</span>
颗棋子，仅看横竖，最多覆盖 <span class="math inline">\(k\)</span>
行，<span class="math inline">\(k\)</span> 列。将剩下的格子平移可以拼成
<span class="math inline">\((n−k)×(n−k)\)</span> 的正方形，该正方形的
<span class="math inline">\(2×(n−k)−1\)</span> 条对角线都要由 <span
class="math inline">\(k\)</span> 个棋子的对角线覆盖。</p>
<p>因此可以列出不等式 <span class="math inline">\(k\leq
2×(n−k)−1\)</span>，化简得 <span class="math inline">\(k\leq
\lfloor{2n−1\over 3}\rfloor\)</span>.</p>
<p>剩下如何构造没看懂.</p>
<h3 id="贪心">贪心</h3>
<p><strong>狄尔沃斯定理</strong></p>
<p>对于任意有限偏序集，其最大反链中元素的数目必等于最小链划分中链的数目。</p>
<p><strong>最长单调子序列<span class="math inline">\(O(n\log
n)\)</span></strong></p>
<p>令 <span class="math inline">\(f[i]\)</span>
为最长上升子序列的末尾元素的最小值，有：<span
class="math inline">\(f[i]\)</span> 单调不减（反证可得），故可以二分维护
遍历原序列，每次都从 <span class="math inline">\(1\to ans\)</span>
中找可替换的元素并替换, 若无 (即 <span class="math inline">\(f[ans] &lt;
a[i]\)</span> ) , <span class="math inline">\(f[++ans] =
a[i]\)</span>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">f[<span class="number">1</span>] = a[<span class="number">1</span>];</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(a[i] &gt; f[ans])<span class="comment">//or &gt;=(看题意)</span></span><br><span class="line">    &#123;</span><br><span class="line">        f[++ ans] = a[i];</span><br><span class="line">        <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (<span class="built_in">lower_bound</span>(f + <span class="number">1</span>, f + ans + <span class="number">1</span>, a[i]) - f);</span><br><span class="line">    f[mid] = a[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>全序集</strong></p>
<p>所有排序本质上都要求是全序集. 也就是两两元素一定能比较,
所以我们每次找出两个元素比较优先级即可.</p>
<p>这种题找出偏序关系然后排个序就行.</p>
<p><strong>结论</strong></p>
<p>通过相邻交换,使得序列单调的次数, 就是逆序对的数量</p>
<p><strong>反悔贪心</strong></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1526/problem/C2">问题 - C2 -
Codeforces</a></p>
<p>遍历时，每喝一个负值药水，就把它放入优先队列（按扣了多少血）中，之后遇到喝不了的负值药水时，看看能不能反悔之前的药水。<strong>(最长的非负前缀和子序列)</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>&gt; p;</span><br><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line"></span><br><span class="line">p.<span class="built_in">push</span>(<span class="number">0</span>);<span class="comment">//防止top时引发re</span></span><br><span class="line"><span class="type">int</span> now = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(now + a[i] &gt;= <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        now += a[i];</span><br><span class="line">        ans ++;</span><br><span class="line">        <span class="keyword">if</span>(a[i] &lt; <span class="number">0</span>)</span><br><span class="line">            p.<span class="built_in">push</span>(- a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(p.<span class="built_in">top</span>() + a[i] &gt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        now += (p.<span class="built_in">top</span>() + a[i]);</span><br><span class="line">        p.<span class="built_in">pop</span>();</span><br><span class="line">        p.<span class="built_in">push</span>(- a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/2037/D">Problem -
2037D - Codeforces</a></p>
<p>同理.</p>
<h3 id="综合思维">综合思维</h3>
<p><strong>排列的最长公共子序列</strong></p>
<p>给出a, b均为 1 到 n 的排列, 求最长公共子列的长度. <span
class="math inline">\(n\leq 1e5\)</span></p>
<p><span class="math inline">\(a:a_1, a_2, a_3, ...a_n\)</span> <span
class="math inline">\(b:a_2, a_7, a_5, ...a_6(\text{eg})\)</span></p>
<p>可证明 a 的子序列均为 b 的下标递增的子序列, 反之成立 故而问题转化为求
b 的最长递增子列</p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1554/C">Problem -
1554C - Codeforces</a></p>
<p><del>是 Mikasa 欸, 我喜欢你</del></p>
<p><strong>题意</strong></p>
<p>给定 <span class="math inline">\(n, m\leq 10^9\)</span>， 求 <span
class="math inline">\(\operatorname{mex}\{n\oplus 0, n\oplus 1, \dots
n\oplus m\}\)</span>。</p>
<p><strong>思路</strong></p>
<p>由异或性质：$ ni = a_ina_i = i $, 故而注意到 $ n $ 为定值时，$ i $
对应唯一 $ a_i $，反之成立。</p>
<p>故： 当 $ 0im $ 时，$ a_i $ 不存在 $ $ 所有未出现的 $ a_i $，都有 $ i
&gt; m $。</p>
<p>问题转化为求 $ {ni| i &gt; m} $，也就是解 “异或不等式” $ nx &gt; m
$。我们转换为等价的不等式： $ nxm + 1 $ (否则要考虑特判)。</p>
<p>记 $ maxi $ 为 $ {n, m + 1} $ 的位数，$ a_{maxii} $ 为 $ a $ 的前
<span class="math inline">\(maxi\)</span> 到 $maxi - i + 1 $ 位(即 $ a $
右移 $ i $ 位)，从高位到低位贪心构造：如果 $ n_{maxii}x_{maxii} (m +
1)_{maxii} $，则 $ x $ 的第 $ i $ 位赋 0，否则赋 1。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    m ++;</span><br><span class="line">    <span class="type">int</span> x = <span class="number">0</span>, maxi = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>((m &gt;&gt; maxi) || (n &gt;&gt; maxi))    </span><br><span class="line">        maxi++;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = maxi - <span class="number">1</span>; i &gt;= <span class="number">0</span>; -- i)</span><br><span class="line">        <span class="keyword">if</span>(( (n &gt;&gt; i) ^ (x &gt;&gt; i) ) &lt; (m &gt;&gt; i))</span><br><span class="line">            x += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">    cout &lt;&lt; x &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="字符串">3. 字符串</h2>
<h3 id="字符哈希">3.1 字符哈希</h3>
<p><strong>模板</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;ull&gt; <span class="title">pre</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span>, <span class="title">power</span><span class="params">(n + <span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> p = <span class="number">127</span>;<span class="comment">//必须是不太小的质数</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)  pre[i] = pre[i - <span class="number">1</span>] * p + s[i];</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)  power[i] = power[i - <span class="number">1</span>] * p;</span><br><span class="line"></span><br><span class="line"><span class="comment">//hash of [l, r]: pre[r] - pre[l - 1] * power[r - l + 1]</span></span><br></pre></td></tr></table></figure>
<p><strong>判断回文</strong></p>
<p>注意二分时要分奇偶: 因为有 len = 3 的回文串, 不一定有 len = 4
的回文串. 复杂度 <span class="math inline">\(O(n\log n)\)</span>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Mikasa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line">    <span class="type">int</span> n = s.<span class="built_in">size</span>();</span><br><span class="line">    s = <span class="string">&#x27; &#x27;</span> + s;</span><br><span class="line">    <span class="function">vt&lt;ull&gt; <span class="title">pre</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span>, <span class="title">rev</span><span class="params">(n + <span class="number">2</span>, <span class="number">0</span>)</span>, <span class="title">power</span><span class="params">(n + <span class="number">2</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">const</span> <span class="type">int</span> p = <span class="number">127</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        pre[i] = pre[i - <span class="number">1</span>] * p + s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        rev[i] = rev[i + <span class="number">1</span>] * p + s[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        power[i] = power[i - <span class="number">1</span>] * p;</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; check = [&amp;](<span class="type">int</span> len) -&gt; <span class="type">bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> l = <span class="number">1</span>; l + len - <span class="number">1</span> &lt;= n; ++l)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> r = l + len - <span class="number">1</span>;</span><br><span class="line">            ull pr = pre[r] - pre[l - <span class="number">1</span>] * power[len], re = rev[l] - rev[r + <span class="number">1</span>] * power[len];</span><br><span class="line">            <span class="keyword">if</span> (pr == re)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> l = <span class="number">1</span>, r = (n + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">check</span>(<span class="number">2</span> * mid - <span class="number">1</span>) ? l = mid, ans = <span class="built_in">max</span>(ans, <span class="number">2</span> * mid - <span class="number">1</span>) : r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    l = <span class="number">1</span>, r = n / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = (l + r + <span class="number">1</span>) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">check</span>(<span class="number">2</span> * mid) ? l = mid, ans = <span class="built_in">max</span>(ans, <span class="number">2</span> * mid) : r = mid - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="字典树">3.2 字典树</h3>
<h4 id="字典树-1">01字典树</h4>
<p><strong>模板类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> get_th(x, i) ((x &gt;&gt; (i - 1)) &amp; 1)         <span class="comment">// 获得 x 的 i-th 的 bool</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> set_th(x, i) (x = x | (1 &lt;&lt; (i - 1)))     <span class="comment">// 强制 x 的 i-th 为 1</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> clear_th(x, i) (x = x &amp; ~(1 &lt;&lt; (i - 1)))   <span class="comment">// 强制 x 的 i-th 为 0</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> make_th(x, i, v) (x = x + (v &lt;&lt; (i - 1))) <span class="comment">// 给 x 加 v * 2 ^ (i-1)</span></span></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//每个结点存的是自己的info</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">node</span>&#123;</span><br><span class="line">    map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; son;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="built_in">node</span>()&#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">xorTrie</span></span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;node&gt; trie;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">xorTrie</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        trie.<span class="built_in">clear</span>();</span><br><span class="line">        trie.<span class="built_in">resize</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">32</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> dig = <span class="built_in">get_th</span>(x, i);</span><br><span class="line">            <span class="keyword">if</span> (trie[now].son[dig] == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                trie[now].son[dig] = trie.<span class="built_in">size</span>();</span><br><span class="line">                trie.<span class="built_in">push_back</span>(&#123;&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">            now = trie[now].son[dig];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">	<span class="comment">// x 异或后的最大值.</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">max_xor</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">32</span>; i &gt;= <span class="number">1</span>; --i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> dig = <span class="built_in">get_th</span>(x, i);</span><br><span class="line">            <span class="type">int</span> op = (trie[now].son[!dig]?(!dig):dig);</span><br><span class="line">            <span class="built_in">make_th</span>(ans, i, op);</span><br><span class="line">            now = trie[now].son[op];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans ^ x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="数学">4. 数学</h2>
<h3 id="基础算法-1">4.1 基础算法</h3>
<h4 id="gcd">gcd</h4>
<p><strong>gcd</strong></p>
<p>求 a, b 的最大公因数/最小公倍数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span> <span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (b == <span class="number">0</span>) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span> (b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">long</span> <span class="type">long</span> lcm = a / <span class="built_in">gcd</span>(a,b) * b;</span><br></pre></td></tr></table></figure>
<p>数据结构维护 gcd, 考虑 <span class="math inline">\(\gcd(a, b) = p
\Leftrightarrow a - b\equiv 0\pmod p\)</span></p>
<p><strong>多元 gcd</strong></p>
<p><span class="math inline">\(\gcd(a, b, c) = \gcd( \gcd(a, b),
c)\)</span></p>
<p>但是一般会枚举因子而非求出多元 gcd</p>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc393/tasks/abc393_e">E - GCD
of Subset</a></p>
<p><strong>题意</strong></p>
<p>给定一个长 n 的数组 a 和整数 k (<span class="math inline">\(a_i\leq
10^6\)</span>, <span class="math inline">\(n, k\leq 1.2\times
10^6\)</span>).</p>
<p>求: 对于每个 i , 从 a 中选择包含 <span
class="math inline">\(a_i\)</span> 的 k 个元素，求所选元素的最大 gcd</p>
<p><strong>思路</strong></p>
<p>常规思路是正着分解 a[i] 因子来解决, 显然会 t.</p>
<p>显然包含 <span class="math inline">\(a_i\)</span> 的 gcd 一定是 <span
class="math inline">\(a_i\)</span> 的因子, 所以可以从小到大遍历 i ,
然后更新 i 的所有倍数的数量.</p>
<p>注意这样复杂度是调和的 <span class="math inline">\(O(m\log m +
n)\)</span>.</p>
<p><strong>代码</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Mikasa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vi <span class="title">cnt</span><span class="params">(maxn + <span class="number">10</span>, <span class="number">0</span>)</span>, <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">        v = <span class="built_in">max</span>(a[i], v), cnt[a[i]]++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//kcnt[i]: i 的所有倍数 cnt 之和</span></span><br><span class="line">    <span class="comment">//ans[i]: i 时的答案</span></span><br><span class="line">    <span class="function">vi <span class="title">kcnt</span><span class="params">(v + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">ans</span><span class="params">(v + <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= v; j += i)</span><br><span class="line">            kcnt[i] += cnt[j];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1 - 1e6</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = i; j &lt;= v; j += i)</span><br><span class="line">            <span class="keyword">if</span> (kcnt[i] &gt;= k)</span><br><span class="line">                ans[j] = <span class="built_in">max</span>(ans[j], i);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        cout &lt;&lt; ans[a[i]] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="快速幂">快速幂</h4>
<p><strong>乘法快速幂</strong></p>
<p>求 <span class="math inline">\(a ^ b \pmod p\)</span></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1226">P1226
【模板】快速幂</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ll <span class="title">fp</span> <span class="params">(ll a, ll b, ll p)</span> </span>&#123;</span><br><span class="line">    ll res = <span class="number">1</span>;</span><br><span class="line">    a %= p;<span class="comment">//优化，减小不必要的运算</span></span><br><span class="line">    <span class="keyword">while</span> (b) &#123;</span><br><span class="line">        <span class="keyword">if</span> (b &amp; <span class="number">1</span>) res = res * a % p;</span><br><span class="line">        b &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        a = (a * a) % p;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="exgcd">EXGCD</h4>
<p>求解二元一次不定方程 <span class="math inline">\(ax + by = \gcd(a,
b)\)</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">exgcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b ,<span class="type">int</span> &amp;x ,<span class="type">int</span> &amp;y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!b)</span><br><span class="line">    &#123;</span><br><span class="line">        x = <span class="number">1</span>, y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> d = <span class="built_in">exgcd</span>(b, a % b, y, x);</span><br><span class="line">    y -= (a / b * x);</span><br><span class="line">    <span class="keyword">return</span> d;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="逆元">逆元</h4>
<p>逆元定义: 若 <span class="math inline">\(p \nmid a\)</span>, 则 <span
class="math inline">\(a\cdot a^{-1}\equiv 1\pmod p\)</span>.</p>
<p><strong>求单个逆元</strong></p>
<ul>
<li>若 p 是质数, 用<strong>费马小定理</strong></li>
</ul>
<p>若 <span class="math inline">\(\gcd(a, p) = 1\)</span> 且 $p $, 则有
<span class="math inline">\(a^p\equiv a\pmod p\)</span>.</p>
<p>故而 <span class="math inline">\(a^{-1}\equiv a^{p - 2}\pmod
p\)</span>. 用快速幂求, 复杂度 <span class="math inline">\(O(\log
p)\)</span>.</p>
<ul>
<li>若 p 不是质数</li>
</ul>
<p>暂时不会.</p>
<p><strong>求 n 以内所有逆元</strong></p>
<p><span class="math inline">\(O(n\log p)\)</span> 可能会 tle, 有 <span
class="math inline">\(O(n)\)</span> 解法.</p>
<p>记 <span class="math inline">\(p = k\cdot i + r\)</span>, 那么有:
<span class="math inline">\(i^{-1}\equiv (p - k)\cdot r^{-1}\pmod
p\)</span>, 初始化 <span class="math inline">\(1^{-1}\equiv 1\pmod
p\)</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inv</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">inv[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> k = p / i, r = p % i;</span><br><span class="line">    inv[i] = (p - k) * inv[r] % p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="mex">mex</h4>
<p>注意 <span class="math inline">\(\text{mex}(s)\leq
s.size\)</span>.</p>
<p><strong>静态区间 <span class="math inline">\(O(n)\)</span> 求所有前 /
后缀 mex</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">get_mex</span><span class="params">(vector&lt;<span class="type">int</span>&gt; a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">cnt</span><span class="params">(a.size() + <span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">mex</span><span class="params">(a.size() + <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; a.<span class="built_in">size</span>(); ++i)  <span class="comment">//求后缀改下顺序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now = a[i];</span><br><span class="line">        <span class="keyword">if</span> (now &lt; cnt.<span class="built_in">size</span>() - <span class="number">1</span>)  cnt[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (cnt[ans])  ans++;</span><br><span class="line">        mex[i] = ans;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> mex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="数论-组合数学">4.2 数论 &amp; 组合数学</h3>
<h4 id="数论基础">数论基础</h4>
<p><strong>勾股数</strong></p>
<p>任意一组勾股数 a, b, c ( <span class="math inline">\(a^2 + b^2=
c^2\)</span> ), 必然有 <span class="math inline">\(60\mid a\cdot b\cdot
c\)</span>.</p>
<p>证明: 容斥可得 a, b, c 中一定有 3 的倍数和 5 的倍数; 反证可得 a, b, c
中一定有 4 的倍数. 故而 abc 是 60 的倍数.</p>
<h4 id="质数">质数</h4>
<p>质因数计数</p>
<p><span class="math display">\[
\omega(n) \simeq \frac{\ln n}{\ln\ln n}
\]</span></p>
<p>因数计数</p>
<p><span class="math display">\[
d(n) \simeq \ln n \leq 2^{1.54\ln n \over \ln\ln n}
\]</span></p>
<p>当 <span class="math inline">\(n \leq 10^9\)</span> 时：<span
class="math inline">\(\max\{d(n)\} &lt; 1500\)</span>; 当 <span
class="math inline">\(n \leq 10^{18}\)</span> 时：<span
class="math inline">\(\max\{d(n)\} &lt; 11000\)</span></p>
<p>质数计数</p>
<p><span class="math display">\[
\pi(n) \simeq \frac{n}{\ln n}
\]</span></p>
<p>质数距离</p>
<p><span class="math display">\[
\simeq \ln p \leq \frac{\ln^2 p}{1.2}
\]</span></p>
<p>特别地：</p>
<p><span class="math display">\[
\sum^n \frac{1}{k} \simeq \ln n, \quad \sum^n \frac{1}{p} \simeq \ln \ln
n, \quad \sum^n \frac{1}{p_i p_{i + 1}} \simeq \ln \ln \ln n, \dots
\]</span></p>
<p>互质距离/质因数计数易算 ( 从小到大质数相乘 <span
class="math inline">\(\prod p_i\gg \prod i\)</span>, 增长很快)</p>
<p><strong>判断单个素数</strong></p>
<p>小常数 <span class="math inline">\(O(\sqrt{n})\)</span>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isP</span><span class="params">(<span class="type">int</span> a)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a == <span class="number">2</span> || a == <span class="number">3</span>)	<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (a &lt;= <span class="number">1</span> || a % <span class="number">2</span> == <span class="number">0</span> || a % <span class="number">3</span> == <span class="number">0</span>)	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> q = <span class="built_in">sqrt</span>(a);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &lt;= q; i += <span class="number">6</span>) </span><br><span class="line">        <span class="keyword">if</span> (a % i == <span class="number">0</span> || a % (i + <span class="number">2</span>) == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>欧拉筛</strong></p>
<p>求前 n 个数中所有素数 <span class="math inline">\(O(n)\)</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; prime;</span><br><span class="line"><span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">np</span><span class="params">(MAXN + <span class="number">5</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//in main</span></span><br><span class="line"><span class="keyword">auto</span> pre = [&amp;]()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= MAXN; ++i)</span><br><span class="line">    &#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!np[i])</span><br><span class="line">            prime.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">0</span>; j &lt; prime.<span class="built_in">size</span>() &amp;&amp; prime[j] * i &lt; MAXN; ++j)</span><br><span class="line">        &#123;</span><br><span class="line">            np[i * prime[j]] = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (i % prime[j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pre</span>();</span><br></pre></td></tr></table></figure>
<h4 id="斐波那契">斐波那契</h4>
<p><strong>皮萨诺周期</strong></p>
<p>模 <span class="math inline">\(m\)</span>
意义下斐波那契数列的周期被称为皮萨诺周期, 记为 <span
class="math inline">\(P(m)\)</span>.</p>
<p>有结论: <span class="math inline">\(P(m) \leq 6m\)</span>, 当且仅当
<span class="math inline">\(m = 2\times 5^k\)</span> 时等号成立.</p>
<p><strong>三角形</strong></p>
<p>假如大小为 <span class="math inline">\(n\)</span> 的可重集合中没有
"能构成三角形的三元组" , 那么最坏情况 (大小最大的)
构造是斐波那契数列.</p>
<h4 id="组合数">组合数</h4>
<p><strong>第二类斯特林数</strong></p>
<p>将 n 个不同的元素拆分成 m 个集合的方案数，记为 <span
class="math inline">\(S(n, m)\)</span>.</p>
<p>通项公式: <span class="math inline">\(S(n, m) = {1\over m!}\sum_{k =
0}^{m}(-1)^kC_{k}^{m}(m - k)^n\)</span></p>
<p>递推式: <span class="math inline">\(S(n, k) = S(n - 1, k - 1) +
k\times S(n - 1, k)\)</span></p>
<p>边界: <span class="math inline">\(S(n, 0) =
!(\text{bool})n\)</span></p>
<h4 id="整除分块">整除分块</h4>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc356/tasks/abc356_e">E -
Max/Min</a></p>
<p>给一个长度为 n 的数组 a, 求: <span
class="math inline">\(\displaystyle
\sum_{i=1}^{n-1}\sum_{j=i+1}^{n}\left\lfloor\frac{\max(a_i,a_j)}{\min(a_i,a_j)}\right\rfloor\)</span>
, <span class="math inline">\(n \leq 2\times 10^5\)</span>, <span
class="math inline">\(a_i \leq 10^6\)</span></p>
<p>排序预处理，问题等价于：给定单调递增数列 a, 求 <span
class="math inline">\(\sum \sum \lfloor \frac{a_i}{a_j}
\rfloor\)</span>.</p>
<p>暴力 $ o(n^2) $ , 考虑优化: 对 <span class="math inline">\(a_i =
3\)</span> 来说, <span class="math inline">\(a_j = 2\)</span> or <span
class="math inline">\(a_j = 3\)</span> 是的贡献是一样的. 所以枚举倍数
<span class="math inline">\(k \in [1,{V\over a_i}]\)</span>,
然后每次计算出做出 k 贡献的数的上下界. 平均复杂度 <span
class="math inline">\(O(n\log n)\)</span>.</p>
<p>注意可能出现: 除了最大的数外, 全是很小的数 ( 比如 1 ), 这样还是 <span
class="math inline">\(O(V^2)\)</span>, 记忆化处理即可. 这样每次遍历时,
<span class="math inline">\(k\)</span> 是一定会增加的,
否则直接用前一次的结果, <span class="math inline">\(O(1)\)</span>
跳到下一个了. 最坏情况下也是 <span class="math inline">\(k = {V\over 1},
{V\over 2}, {V\over 3} ... 1\)</span>, 调和级数之和 <span
class="math inline">\(O(\log V)\)</span>.</p>
<p>故而最坏情况下的复杂度 <span class="math inline">\(O(n\log V + V +
n\log n)\)</span>.</p>
<p>注意 <code>map</code> 也是 <span class="math inline">\(\log\)</span>
级别的, 如果用 <code>map</code> 复杂度就是 <span
class="math inline">\(O(V\log^2V + n\log n)\)</span>, 会被卡掉.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mikasa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vi <span class="title">a</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="type">int</span> v = *<span class="built_in">max_element</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">end</span>());</span><br><span class="line">    <span class="function">vi <span class="title">cnt</span><span class="params">(v + <span class="number">10</span>, <span class="number">0</span>)</span>, <span class="title">cnts</span><span class="params">(v + <span class="number">10</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> e : a)</span><br><span class="line">        cnt[e]++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v; ++i)</span><br><span class="line">        cnts[i] = cnts[i - <span class="number">1</span>] + cnt[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>, last = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (a[i] == a[i - <span class="number">1</span>])</span><br><span class="line">        &#123;</span><br><span class="line">            ans += last;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        last = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt;= v / a[i]; k++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> l = <span class="built_in">max</span>(a[i], k * a[i] - <span class="number">1</span>), r = <span class="built_in">min</span>(v, (k + <span class="number">1</span>) * a[i] - <span class="number">1</span>);</span><br><span class="line">            last += (cnts[r] - cnts[l]) * k;</span><br><span class="line">        &#125;</span><br><span class="line">        ans += last;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= v; ++i)</span><br><span class="line">        ans += cnt[i] * (cnt[i] - <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="博弈论">4.3 博弈论</h3>
<p><strong>公平组合游戏</strong></p>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/Wolfycz/p/8430991.html">浅谈算法——博弈论 -
Wolfycz - 博客园</a></p>
<p>定义: 状态 N 为当前必胜; 状态 P 为当前必输.</p>
<p>必然要提及 SG 函数.</p>
<p>假定每个状态只有一个参量, 那么定义 SG 函数: <span
class="math inline">\(f(x) = \text{mex}\{f(y_1), f(y_2)\dots\}\)</span>,
其中 <span class="math inline">\(f(y)\)</span> 是 <span
class="math inline">\(f(x)\)</span> 的后继状态.</p>
<p>终止状态的 SG 值显然为 0，并且 SG 值为 0 的状态就是 P
状态，SG值不为0的状态就是 N 状态。</p>
<p>从结果倒推: 假如</p>
<h2 id="数据结构">5. 数据结构</h2>
<p>数据结构只能是工具! 有很多专精数据结构,
什么树状数组套权值线段树写的起飞的小朋友. 但是不会做题 ——
很多人会陷进去骗自己.</p>
<table>
<colgroup>
<col style="width: 11%" />
<col style="width: 88%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">数据结构</th>
<th style="text-align: center;">功能</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;">ST 表</td>
<td style="text-align: center;"><span
class="math inline">\(O(1)\)</span>查询区间<strong>可重复贡献</strong></td>
</tr>
<tr>
<td style="text-align: center;">莫队</td>
<td style="text-align: center;"><span class="math inline">\(O(q
\sqrt{n})\)</span>完成所有离线静态的区间查询,
处理复杂查询时容易实现</td>
</tr>
<tr>
<td style="text-align: center;">并查集</td>
<td style="text-align: center;"><span
class="math inline">\(O(1)\)</span>合并查询</td>
</tr>
<tr>
<td style="text-align: center;">树状数组</td>
<td style="text-align: center;">弱化版线段树, <span
class="math inline">\(O(\log
n)\)</span>查询区间<strong>不可重复贡献</strong></td>
</tr>
<tr>
<td style="text-align: center;">线段树</td>
<td style="text-align: center;">宇宙尽头树, <span
class="math inline">\(O(\log n)\)</span>增删查改</td>
</tr>
</tbody>
</table>
<h3 id="基础数据结构">基础数据结构</h3>
<p>前缀和数组见"基础算法"</p>
<p>ST <strong>表</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//第二维多开一点</span></span><br><span class="line"><span class="type">int</span> dp[maxn][(<span class="type">int</span>)<span class="built_in">log2</span>(maxn) + <span class="number">5</span>], a[maxn];</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    cin&gt;&gt;a[i];</span><br><span class="line">    dp[i][<span class="number">0</span>] = a[i]; <span class="comment">//赋初值</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//注意循环顺序, 算完一层才能算下一层</span></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">log2</span>(n); ++ j)</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)) &lt;= n; ++ i)</span><br><span class="line">        dp[i][j] = <span class="built_in">max</span>(dp[i][j - <span class="number">1</span>], dp[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m --)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> l, r;</span><br><span class="line">    cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">    <span class="type">int</span> k = <span class="built_in">log2</span>(r - l + <span class="number">1</span>);</span><br><span class="line">    cout &lt;&lt; <span class="built_in">max</span>(dp[l][k], dp[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2050/problem/F">Problem - F -
Codeforces</a></p>
<p><strong>题意</strong></p>
<p>给定数列a和q次询问. 每次询问给出 l, r, 求: <span
class="math inline">\(\max m\)</span>, 使得 <span
class="math inline">\((a_l \equiv a_{l + 1} \equiv \dots \equiv a_r\pmod
m)^*\)</span>.</p>
<p><strong>思路</strong></p>
<p><span class="math inline">\(^*\)</span> 式转化为 <span
class="math inline">\(|a_{l + 1} - a_l|\equiv \dots \equiv |a_r - a_{r -
1}|\equiv 0\pmod m\)</span>, 记 <span class="math inline">\(d_i = |a_{i
+ 1} - a_i|\)</span>, 则 <span class="math inline">\(m = \gcd(d_l,\dots
d_r)\)</span>. <span class="math inline">\(\gcd\)</span>
有结合律和可重复性, 故使用 st 表.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> dp[maxn][(<span class="type">int</span>)<span class="built_in">log2</span>(maxn) + <span class="number">5</span>], a[maxn], d[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++ i)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        d[i] = <span class="built_in">abs</span>(a[i] - a[i - <span class="number">1</span>]);</span><br><span class="line">        dp[i][<span class="number">0</span>] = d[i];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= <span class="built_in">log2</span>(n - <span class="number">1</span>); ++ j)</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>)) &lt; n; ++ i)</span><br><span class="line">            dp[i][j] = <span class="built_in">gcd</span>(dp[i][j - <span class="number">1</span>], dp[i + (<span class="number">1</span> &lt;&lt; (j - <span class="number">1</span>))][j - <span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span>(r == l)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        r--;</span><br><span class="line">        <span class="type">int</span> k = <span class="built_in">log2</span>(r - l + <span class="number">1</span>);</span><br><span class="line">        cout &lt;&lt; <span class="built_in">gcd</span>(dp[l][k], dp[r - (<span class="number">1</span> &lt;&lt; k) + <span class="number">1</span>][k]) &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>单调栈</strong></p>
<p>单调栈能解决的问题就很少，基本上都是求一个数列中符合要求的最近的数，给出模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)<span class="comment">//顺序要因题而异</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; a[i] is priority than a[st.<span class="built_in">top</span>()] )</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">    st.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P5788">P5788
【模板】单调栈</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)<span class="comment">//顺序要因题而异</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; a[i] is priority than a[st.<span class="built_in">top</span>()] )</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    <span class="keyword">if</span>(st.<span class="built_in">empty</span>())<span class="comment">//把栈里所有值都弹出了，说明这个值是最优先的</span></span><br><span class="line">        ans[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        ans[i] = st.<span class="built_in">top</span>().order;</span><br><span class="line">    st.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc372/tasks/abc372_d#:~:text=D%20-%20Buildi">D
- Buildings</a></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = n; i &gt;= <span class="number">1</span>; -- i)</span><br><span class="line">&#123;</span><br><span class="line">    ans[i] = st.<span class="built_in">size</span>();</span><br><span class="line">    <span class="keyword">while</span>(!st.<span class="built_in">empty</span>() &amp;&amp; h[i] &gt; h[st.<span class="built_in">top</span>()])</span><br><span class="line">        st.<span class="built_in">pop</span>();</span><br><span class="line">    st.<span class="built_in">push</span>(i);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>单调队列</strong></p>
<p>值得注意地是，单调队列是一个双向队列。单调队列和滑动窗口紧密相连，也能用来优化一些最值
dp，给出模板：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span>(!q.<span class="built_in">empty</span>() &amp;&amp; q.<span class="built_in">front</span>() should be over)</span><br><span class="line">		q.<span class="built_in">pop_front</span>();</span><br><span class="line">    <span class="comment">//设窗口大小为 k，显然当 i &lt;= k 时要一直塞入，直到窗口已经有 k 个值时才开始运作</span></span><br><span class="line">	<span class="keyword">while</span>(!q.<span class="built_in">empty</span>() &amp;&amp; i &gt; k &amp;&amp; q.<span class="built_in">back</span>().data is priority than a[i].data)</span><br><span class="line">		q.<span class="built_in">pop_back</span>();</span><br><span class="line">	q.<span class="built_in">push_back</span>(a[i]);</span><br><span class="line">	ans[i] = q.<span class="built_in">front</span>().data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="并查集">并查集</h3>
<p>用树的结构来合并两个集合，也能以近乎 <span
class="math inline">\(O(1)\)</span> 的速度查询某个值是否在该集合中</p>
<p><strong>简化版</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span></span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; f;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) : <span class="built_in">f</span>(n) &#123; std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x])</span><br><span class="line">            x = f[x] = f[f[x]];<span class="comment">// 向上走 + 上提父节点</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        fx = <span class="built_in">find</span>(x), fy = <span class="built_in">find</span>(y);</span><br><span class="line">        f[fx] = fy;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>完全体</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">DSU</span></span><br><span class="line">&#123;</span><br><span class="line">    std::vector&lt;<span class="type">int</span>&gt; f, _size;</span><br><span class="line">    <span class="built_in">DSU</span>(<span class="type">int</span> n) : <span class="built_in">f</span>(n), _size(n, <span class="number">1</span>) &#123; std::<span class="built_in">iota</span>(f.<span class="built_in">begin</span>(), f.<span class="built_in">end</span>(), <span class="number">0</span>); &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (x != f[x])</span><br><span class="line">            x = f[x] = f[f[x]];<span class="comment">// 向上走 + 上提父节点</span></span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        x = <span class="built_in">find</span>(x), y = <span class="built_in">find</span>(y);</span><br><span class="line">        <span class="keyword">if</span> (x == y)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        _size[x] += _size[y];</span><br><span class="line">        f[y] = x;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">same</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">find</span>(x) == <span class="built_in">find</span>(y); &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">size</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123; <span class="keyword">return</span> _size[<span class="built_in">find</span>(x)]; &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p><strong>并查集的访问</strong></p>
<p>同个集合只访问一次</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">merge</span>(u, v);</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> fx = <span class="built_in">find</span>(i);</span><br><span class="line">    <span class="keyword">if</span>( done[fx] )	<span class="keyword">continue</span>;</span><br><span class="line">    done[fx] = <span class="literal">true</span>;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="树状数组">树状数组</h3>
<p><strong>线段树的泛用性大于树状数组，但是树状数组比线段树简单</strong></p>
<p>对于一个数组，差分可以<span
class="math inline">\(O(1)\)</span>修改区间（加同一个数）；前缀和可以<span
class="math inline">\(O(1)\)</span>查询区间。（对单点的修改和查询，可视为弱化的区间修改和查询）</p>
<p>如何看 "每个结点里存什么"? 看知道小区间的什么才能推出大区间,
所以可能要存一些辅助信息.</p>
<figure>
<img
src="https://github.com/Blade-of-Mikasa/Img/blob/main/In_files/FwTree.png?raw=true"
alt="树状数组" />
<figcaption aria-hidden="true">树状数组</figcaption>
</figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; <span class="comment">// 1-index, 调用时开(n)</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Fenwick</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;T&gt; tree;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">Fenwick</span>(<span class="type">int</span> Size = <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        n = Size;</span><br><span class="line">        tree.<span class="built_in">assign</span>(n + <span class="number">1</span>, T&#123;&#125;); </span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">add</span><span class="params">(<span class="type">int</span> x, <span class="type">const</span> T &amp;d)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &lt;= n; i += (i &amp; -i))</span><br><span class="line">            tree[i] += d;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">sum</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        T ans&#123;&#125;;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = x; i &gt; <span class="number">0</span>; i -= (i &amp; -i))</span><br><span class="line">            ans += tree[i];</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">T <span class="title">rangeSum</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">sum</span>(r) - <span class="built_in">sum</span>(l - <span class="number">1</span>); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="线段树">线段树</h3>
<figure>
<img
src="https://github.com/Blade-of-Mikasa/Img/blob/main/In_files/SGT.png?raw=true"
alt="线段树" />
<figcaption aria-hidden="true">线段树</figcaption>
</figure>
<p>线段树可以在 <span class="math inline">\(O(\log n)\)</span>
的时间复杂度内实现单点修改、区间修改、区间查询（区间求和，求区间最大值，求区间最小值)等操作。</p>
<p>常数比较大, 由于最坏情况下区间会分裂成 4 个情况 2.3.1/2 (如图, 最坏是
2.2 -&gt; 两个 2.3.3 -&gt; 四个 2.3.1/2 ), 所以约为 <span
class="math inline">\(O(4\log n)\)</span>.</p>
<h4 id="板子"><strong>板子</strong></h4>
<p><strong>单点修改</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; tree, a;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123; <span class="keyword">return</span> now &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123; <span class="keyword">return</span> now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">auto</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123; tree[now] = tree[<span class="built_in">ls</span>(now)] + tree[<span class="built_in">rs</span>(now)]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bulid</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[now] = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bulid</span>(<span class="built_in">ls</span>(now), l, mid), <span class="built_in">bulid</span>(<span class="built_in">rs</span>(now), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// if (l &gt; r) return 0;</span></span><br><span class="line">    <span class="keyword">if</span> (l &lt;= pl &amp;&amp; pr &lt;= r) <span class="keyword">return</span> tree[p];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pm = pl + pr &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= pm) ans += <span class="built_in">query</span>(l, r, <span class="built_in">ls</span>(p), pl, pm);</span><br><span class="line">    <span class="keyword">if</span> (pm &lt; r) ans += <span class="built_in">query</span>(l, r, <span class="built_in">rs</span>(p), pm + <span class="number">1</span>, pr);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">update</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> v, <span class="type">int</span> now, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == id &amp;&amp; r == id)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[now] += v;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    (id &lt;= mid) ? <span class="built_in">update</span>(id, v, <span class="built_in">ls</span>(now), l, mid) : <span class="built_in">update</span>(id, v, <span class="built_in">rs</span>(now), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(now);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>区间修改</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; tree, a, tag;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123; <span class="keyword">return</span> now &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123; <span class="keyword">return</span> now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">addtag</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> d)</span> </span>&#123; tag[p] += d, tree[p] += d * (pr - pl + <span class="number">1</span>); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123; tree[now] = tree[<span class="built_in">ls</span>(now)] + tree[<span class="built_in">rs</span>(now)]; &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushdown</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (!tag[p]) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> mid = pl + pr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">addtag</span>(<span class="built_in">ls</span>(p), pl, mid, tag[p]), <span class="built_in">addtag</span>(<span class="built_in">rs</span>(p), mid + <span class="number">1</span>, pr, tag[p]);</span><br><span class="line">    tag[p] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">bulid</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">    &#123;</span><br><span class="line">        tree[now] = a[l];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">bulid</span>(<span class="built_in">ls</span>(now), l, mid), <span class="built_in">bulid</span>(<span class="built_in">rs</span>(now), mid + <span class="number">1</span>, r);</span><br><span class="line">    <span class="built_in">pushup</span>(now);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">query</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= pl &amp;&amp; pr &lt;= r)  <span class="keyword">return</span> tree[p];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> pm = pl + pr &gt;&gt; <span class="number">1</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= pm)  ans += <span class="built_in">query</span>(l, r, <span class="built_in">ls</span>(p), pl, pm);</span><br><span class="line">    <span class="keyword">if</span> (pm &lt; r)  ans += <span class="built_in">query</span>(l, r, <span class="built_in">rs</span>(p), pm + <span class="number">1</span>, pr);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">update</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> d, <span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= pl &amp;&amp; pr &lt;= r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">addtag</span>(p, pl, pr, d);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pushdown</span>(p, pl, pr);</span><br><span class="line">    <span class="type">int</span> pm = pl + pr &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span> (l &lt;= pm)  <span class="built_in">update</span>(l, r, d, <span class="built_in">ls</span>(p), pl, pm);</span><br><span class="line">    <span class="keyword">if</span> (pm &lt; r)  <span class="built_in">update</span>(l, r, d, <span class="built_in">rs</span>(p), pm + <span class="number">1</span>, pr);</span><br><span class="line">    <span class="built_in">pushup</span>(p);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>模板类</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Lazy-Tag Segment Tree, 注意接口是 1-index.</span></span><br><span class="line"><span class="comment">// 注意缺省 info 可能对 info 合并造成影响</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">Info</span>, <span class="keyword">class</span> <span class="title class_">Tag</span>&gt;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">LazySegmentTree</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    std::vector&lt;Info&gt; info;</span><br><span class="line">    std::vector&lt;Tag&gt; tag;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">ls</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123; <span class="keyword">return</span> now &lt;&lt; <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">rs</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123; <span class="keyword">return</span> now &lt;&lt; <span class="number">1</span> | <span class="number">1</span>; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">int</span> now, <span class="type">const</span> Tag &amp;v)</span> </span>&#123; info[now].<span class="built_in">apply</span>(v), tag[now].<span class="built_in">apply</span>(v); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">pull</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123; info[now] = info[<span class="built_in">ls</span>(now)] + info[<span class="built_in">rs</span>(now)]; &#125;</span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> now)</span> </span>&#123; <span class="built_in">apply</span>(<span class="built_in">ls</span>(now), tag[now]), <span class="built_in">apply</span>(<span class="built_in">rs</span>(now), tag[now]), tag[now] = <span class="built_in">Tag</span>(); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> now, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> id, <span class="type">const</span> Info &amp;v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (r == l &amp;&amp; l == id)</span><br><span class="line">        &#123;</span><br><span class="line">            info[now] = v;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">push</span>(now);</span><br><span class="line">        (id &lt;= mid) ? <span class="built_in">modify</span>(<span class="built_in">ls</span>(now), l, mid, id, v) : <span class="built_in">modify</span>(<span class="built_in">rs</span>(now), mid + <span class="number">1</span>, r, id, v);</span><br><span class="line">        <span class="built_in">pull</span>(now);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> l, <span class="type">int</span> r)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pr &lt; l || r &lt; pl)</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">Info</span>();</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= pl &amp;&amp; pr &lt;= r)</span><br><span class="line">            <span class="keyword">return</span> info[p];</span><br><span class="line"></span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="type">int</span> pm = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="built_in">ls</span>(p), pl, pm, l, r) + <span class="built_in">rangeQuery</span>(<span class="built_in">rs</span>(p), pm + <span class="number">1</span>, pr, l, r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeApply</span><span class="params">(<span class="type">int</span> p, <span class="type">int</span> pl, <span class="type">int</span> pr, <span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> Tag &amp;v)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pr &lt; l || r &lt; pl)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= pl &amp;&amp; pr &lt;= r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">apply</span>(p, v);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">push</span>(p);</span><br><span class="line">        <span class="type">int</span> pm = (pl + pr) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span> (l &lt;= pm)</span><br><span class="line">            <span class="built_in">rangeApply</span>(<span class="built_in">ls</span>(p), pl, pm, l, r, v);</span><br><span class="line">        <span class="keyword">if</span> (pm &lt; r)</span><br><span class="line">            <span class="built_in">rangeApply</span>(<span class="built_in">rs</span>(p), pm + <span class="number">1</span>, pr, l, r, v);</span><br><span class="line">        <span class="built_in">pull</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LazySegmentTree</span>() : <span class="built_in">n</span>(<span class="number">0</span>) &#123;&#125;</span><br><span class="line">    <span class="built_in">LazySegmentTree</span>(<span class="type">int</span> n_, Info v_ = <span class="built_in">Info</span>()) &#123; <span class="built_in">init</span>(n_, v_); &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="built_in">LazySegmentTree</span>(std::vector&lt;T&gt; init_) &#123; <span class="built_in">init</span>(init_); &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(<span class="type">int</span> n_, Info v_ = Info())</span> </span>&#123; <span class="built_in">init</span>(std::<span class="built_in">vector</span>(n_, v_)); &#125;</span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">class</span> <span class="title class_">T</span>&gt;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">init</span><span class="params">(std::vector&lt;T&gt; init_)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        n = init_.<span class="built_in">size</span>() - <span class="number">1</span>; <span class="comment">// input is 1-index</span></span><br><span class="line">        info.<span class="built_in">assign</span>((<span class="number">4</span> &lt;&lt; std::__lg((<span class="type">signed</span>)n)) + <span class="number">5</span>, <span class="built_in">Info</span>());</span><br><span class="line">        tag.<span class="built_in">assign</span>((<span class="number">4</span> &lt;&lt; std::__lg((<span class="type">signed</span>)n)) + <span class="number">5</span>, <span class="built_in">Tag</span>());</span><br><span class="line"></span><br><span class="line">        <span class="comment">// dfs 序建树</span></span><br><span class="line">        std::function&lt;<span class="type">void</span>(<span class="type">int</span>, <span class="type">int</span>, <span class="type">int</span>)&gt; build = [&amp;](<span class="type">int</span> now, <span class="type">int</span> l, <span class="type">int</span> r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (r == l)</span><br><span class="line">            &#123;</span><br><span class="line">                info[now] = init_[l];</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">            <span class="built_in">build</span>(<span class="built_in">ls</span>(now), l, mid), <span class="built_in">build</span>(<span class="built_in">rs</span>(now), mid + <span class="number">1</span>, r);</span><br><span class="line">            <span class="built_in">pull</span>(now);</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        <span class="built_in">build</span>(<span class="number">1</span>, <span class="number">1</span>, n);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 令 id-th 为 v</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">modify</span><span class="params">(<span class="type">int</span> id, <span class="type">const</span> Info &amp;v)</span> </span>&#123; <span class="built_in">modify</span>(<span class="number">1</span>, <span class="number">1</span>, n, id, v); &#125;</span><br><span class="line">    <span class="comment">// 返回区间 [x, y] 的答案</span></span><br><span class="line">    <span class="function">Info <span class="title">rangeQuery</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">rangeQuery</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r); &#125;</span><br><span class="line">    <span class="comment">// 范围更新 [x, y]</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">rangeApply</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">const</span> Tag &amp;v)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">rangeApply</span>(<span class="number">1</span>, <span class="number">1</span>, n, l, r, v); &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Tag</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 需要成员/(缺省)构造/apply(Tag)/重载+</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">Tag</span>(<span class="type">int</span> a = <span class="number">0</span>) &#123; x = a; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> Tag &amp;t)</span> &amp;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Info</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 需要成员/(缺省)构造/apply(Tag)/重载+</span></span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    <span class="built_in">Info</span>(<span class="type">int</span> a = <span class="number">0</span>) &#123; x = a; &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">apply</span><span class="params">(<span class="type">const</span> Tag &amp;t)</span> &amp;</span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Info <span class="keyword">operator</span>+(<span class="type">const</span> Info &amp;a, <span class="type">const</span> Info &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        <span class="comment">//...</span></span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P3740">P3740 贴海报</a></p>
<p>在 <span class="math inline">\([1, n]\)</span>上先后给 <span
class="math inline">\(m\)</span> 个线段 <span
class="math inline">\([A_i, B_i]\)</span>, 线段之间会覆盖,
问最后有多少线段未被完全覆盖?</p>
<p><strong>浮水法</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> A[maxn], B[maxn];</span><br><span class="line"><span class="type">bool</span> done[MAXN &lt;&lt; <span class="number">2</span>];</span><br><span class="line"><span class="type">int</span> n, m;</span><br><span class="line"><span class="type">bool</span> ok;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">pushup</span><span class="params">(<span class="type">int</span> rt)</span> </span>&#123; done[rt] = (done[rt &lt;&lt; <span class="number">1</span>] &amp; done[rt &lt;&lt; <span class="number">1</span> | <span class="number">1</span>]); &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">change</span><span class="params">(<span class="type">int</span> l, <span class="type">int</span> r, <span class="type">int</span> rt, <span class="type">int</span> L, <span class="type">int</span> R)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(done[rt])</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(L &lt;= l &amp;&amp; r &lt;= R)</span><br><span class="line">    &#123;</span><br><span class="line">        ok = <span class="number">1</span>;</span><br><span class="line">        done[rt] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> mid = (l + r) &gt;&gt; <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(mid &lt; R)  <span class="built_in">change</span>(mid + <span class="number">1</span>, r, (rt &lt;&lt; <span class="number">1</span>) + <span class="number">1</span>, L, R);</span><br><span class="line">    <span class="keyword">if</span>(mid &gt;= L)    <span class="built_in">change</span>(l, mid, (rt &lt;&lt; <span class="number">1</span>), L, R);</span><br><span class="line">    <span class="built_in">pushup</span>(rt); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">Clear</span>(done);</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">        cin&gt;&gt;A[i]&gt;&gt;B[i];</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = m; i &gt; <span class="number">0</span>; -- i)</span><br><span class="line">    &#123;</span><br><span class="line">        ok = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">change</span>(<span class="number">1</span>, n, <span class="number">1</span>, A[i], B[i]);</span><br><span class="line">        <span class="keyword">if</span>(ok)</span><br><span class="line">            ans++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="思想">思想</h4>
<p>数据结构要配合各种 trick 用</p>
<p><strong>维护值域 (y轴)</strong></p>
<p>逆序对: 用离散化的值来当下标, 等价于从左往右每次查询所有 index 大于
now = a[i] 的数量和, 然后在 index = now 处单点修改 ( +1 ).</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/207172794">记录详情</a></p>
<p><strong>二维数点</strong></p>
<p>离线 + 按 x 升序维护 y 轴 + 逆运算 (<span class="math inline">\([l,
r] = [1, r] - [1, l]\)</span>)</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/209166022">记录详情</a></p>
<h3 id="分块-莫队">分块 &amp; 莫队</h3>
<p>分块</p>
<p><strong>建块</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> belong[MAXN];</span><br><span class="line"><span class="type">int</span> bg[maxn], ed[maxn], tag[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> block = <span class="built_in">sqrt</span>(n), t = n / block;</span><br><span class="line"><span class="keyword">if</span>(n % block) ++ t;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    belong[i] = (i - <span class="number">1</span>) / block + <span class="number">1</span>; </span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= t; ++ i)</span><br><span class="line">&#123;  </span><br><span class="line">    bg[i] = (i - <span class="number">1</span>) * block + <span class="number">1</span>;</span><br><span class="line">    ed[i] = i * block;</span><br><span class="line">&#125;</span><br><span class="line">ed[t] = n;</span><br></pre></td></tr></table></figure>
<p><strong>单点修改 + 区间最值</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分块</span></span><br><span class="line"><span class="type">int</span> block = <span class="built_in">sqrt</span>(n), t = n / block + (<span class="type">bool</span>)(n % block);</span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">v</span><span class="params">(t + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> belong = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">int</span></span><br><span class="line">&#123; <span class="built_in">return</span> (x - <span class="number">1</span>) / block + <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> bg = [&amp;](<span class="type">int</span> i) -&gt; <span class="type">int</span></span><br><span class="line">&#123; <span class="built_in">return</span> (i - <span class="number">1</span>) * block + <span class="number">1</span>; &#125;;</span><br><span class="line"><span class="keyword">auto</span> ed = [&amp;](<span class="type">int</span> i) -&gt; <span class="type">int</span></span><br><span class="line">&#123; <span class="built_in">return</span> (i == t) ? n : i * block; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//区间操作</span></span><br><span class="line"><span class="keyword">auto</span> check = [&amp;](<span class="type">int</span> l, <span class="type">int</span> r) -&gt; <span class="type">int</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> tl = <span class="built_in">belong</span>(l), tr = <span class="built_in">belong</span>(r);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = l; i &lt;= <span class="built_in">min</span>(r, <span class="built_in">ed</span>(tl)); ++i)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> th = tl + <span class="number">1</span>; th &lt; tr; ++th)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, v[th]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">max</span>(l, <span class="built_in">bg</span>(tr)); i &lt;= r; ++i)</span><br><span class="line">        ans = <span class="built_in">max</span>(ans, a[i]);</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> modify = [&amp;](<span class="type">int</span> i, <span class="type">int</span> x) -&gt; <span class="type">void</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> th = <span class="built_in">belong</span>(i), now = a[i];</span><br><span class="line">    a[i] = x;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//类剪枝, 如果修改点不影响区间最值, 就不遍历</span></span><br><span class="line">    <span class="keyword">if</span> (v[th] &lt; now)</span><br><span class="line">        v[th] = <span class="built_in">max</span>(v[th], now);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        v[th] = *<span class="built_in">max_element</span>(a.<span class="built_in">begin</span>() + <span class="built_in">bg</span>(th) + <span class="number">1</span>, a.<span class="built_in">begin</span>() + <span class="built_in">ed</span>(th) + <span class="number">1</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="树上问题">6. 树上问题</h2>
<h4 id="建树和遍历">建树和遍历</h4>
<p><strong>遍历</strong></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2070/problem/D">Problem - D -
Codeforces</a></p>
<h4 id="lca">LCA</h4>
<p>目前只会不带修. 带修太难.</p>
<p><strong>倍增</strong></p>
<p>预处理 <span class="math inline">\(O(n\log n)\)</span>, 查询 <span
class="math inline">\(O(\log n)\)</span>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, s;</span><br><span class="line">cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line"><span class="function">vi <span class="title">deep</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line"><span class="function">vector <span class="title">fa</span><span class="params">(n + <span class="number">1</span>, vi(log2(n) + <span class="number">5</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">vt&lt;vt&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">e</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    e[a].<span class="built_in">push_back</span>(b);</span><br><span class="line">    e[b].<span class="built_in">push_back</span>(a);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//get deep[] and fa[][]</span></span><br><span class="line"><span class="keyword">auto</span> pre = [&amp;](<span class="type">int</span> n, <span class="type">int</span> s)-&gt;<span class="type">void</span></span><br><span class="line">&#123;</span><br><span class="line">    vi <span class="built_in">done</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">    queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">    q.<span class="built_in">push</span>(s), deep[s] = <span class="number">1</span>, done[s] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> nt : e[now])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(done[nt])  <span class="keyword">continue</span>;</span><br><span class="line">            deep[nt] = deep[now] + <span class="number">1</span>, fa[nt][<span class="number">0</span>] = now;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">log2</span>(n) + <span class="number">1</span>; ++i)</span><br><span class="line">                fa[nt][i] = fa[ fa[nt][i - <span class="number">1</span>] ][i - <span class="number">1</span>];</span><br><span class="line">            q.<span class="built_in">push</span>(nt);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">auto</span> lca = [&amp;](<span class="type">int</span> a, <span class="type">int</span> b)-&gt;<span class="type">int</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (deep[a] &lt; deep[b])  <span class="built_in">swap</span>(a, b);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 先放到同一高度</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="built_in">log2</span>(n) + <span class="number">1</span>; k &gt;= <span class="number">0</span>; --k)</span><br><span class="line">        <span class="keyword">if</span> (deep[ fa[a][k] ] &gt;= deep[b])</span><br><span class="line">            a = fa[a][k];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (a == b)  <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// a, b 上移</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="built_in">log2</span>(n) + <span class="number">1</span>; k &gt;= <span class="number">0</span>; --k)</span><br><span class="line">        <span class="keyword">if</span> (fa[a][k] != fa[b][k])</span><br><span class="line">            a = fa[a][k], b = fa[b][k];</span><br><span class="line">    <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">pre</span>(n, s);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span>(m --)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> a, b;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">lca</span>(a, b) &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>欧拉序 + ST 表</strong></p>
<p>貌似很简单, 比上面那个好学很多?</p>
<p>预处理 <span class="math inline">\(O(n\log n)\)</span>, 查询 <span
class="math inline">\(O(1)\)</span>.</p>
<p>考完试再学!</p>
<h4 id="启发式合并">启发式合并</h4>
<p><a
target="_blank" rel="noopener" href="https://www.cnblogs.com/7KByte/p/16143270.html">【笔记】启发式合并
- 7KByte - 博客园 (cnblogs.com)</a></p>
<p>给定 n 个集合，每个集合开始只有 1 个数，每次合并两个集合</p>
<p>直接做显然是 <span class="math inline">\(O(n^{2})\)</span></p>
<p>每次合并都选择较小的一个集合，将它合并到较大的集合上</p>
<p>看上去本质上没有改变，但时间复杂度降低至 <span
class="math inline">\(O(n\log n)\)</span>.
因为对于每个元素，每次合并一定是从小的集合合并到大的集合，所以合并后的集合大小一定翻倍，那么一个元素最多移动
<span class="math inline">\(\log n\)</span> 次，总时间复杂度为 <span
class="math inline">\(O(n\log n)\)</span></p>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc372/tasks/abc372_e?lang=en">E
- K-th Largest Connected Components</a></p>
<p>给一个 n 阶无向零图, 每次操作会连一条边或者询问 v 所在连通块的第 k
大顶点.</p>
<p>并查集 + set 维护.</p>
<p>最坏情况下时间复杂度为 <span class="math inline">\(O((n^2 + q)\log
n)\)</span> , 启发式合并优化到时间复杂度 <span
class="math inline">\(O((n\log n + q)\log n)\)</span>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">set&lt;<span class="type">int</span>&gt; s[maxn];</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> n, q;</span><br><span class="line"><span class="type">int</span> p[maxn];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p[x] != x) p[x] = <span class="built_in">find</span>(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    p[ <span class="built_in">find</span>(a) ] = <span class="built_in">find</span>( p[b] );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;q;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i] = i;</span><br><span class="line">        s[i].<span class="built_in">insert</span>(i);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(q --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> buf, u, v, k;</span><br><span class="line">        cin&gt;&gt;buf;</span><br><span class="line">        <span class="keyword">if</span>(buf == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">            <span class="type">int</span> fu = <span class="built_in">find</span>(u), fv = <span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(fu == fv)    <span class="keyword">continue</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span>(s[fu].<span class="built_in">size</span>() &gt; s[fv].<span class="built_in">size</span>())</span><br><span class="line">                <span class="built_in">swap</span>(fv, fu);</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> tt : s[fu])</span><br><span class="line">                s[fv].<span class="built_in">insert</span>(tt);</span><br><span class="line">            <span class="built_in">merge</span>(fu, fv);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( buf == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cin&gt;&gt;v&gt;&gt;k;</span><br><span class="line">            <span class="type">int</span> fv = <span class="built_in">find</span>(v);</span><br><span class="line">            <span class="keyword">if</span>(s[fv].<span class="built_in">size</span>() &lt; k)</span><br><span class="line">                cout&lt;&lt;<span class="number">-1</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout&lt;&lt;*<span class="built_in">prev</span>(s[fv].<span class="built_in">end</span>(), k)&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="ps-神秘结论">PS 神秘结论</h4>
<p><strong>时间戳</strong></p>
<p>dfs 预处理后, 能快速判断一个结点是否为 u 的子孙 / 祖先.</p>
<p><strong>性质</strong></p>
<ul>
<li><p><span class="math inline">\(t_{\text{in}} &gt;
t&#39;_{\text{in}}\Leftrightarrow t_{\text{out}} &gt;
t&#39;_{\text{out}}\)</span></p></li>
<li><p>u 是 v 的祖先 <span
class="math inline">\(\Leftrightarrow\)</span> <span
class="math inline">\(t_{\text{in}}(u) &lt; t_{\text{in}}(v),
t_{\text{out}}(u) &gt; t_{\text{out}}(v)\)</span></p></li>
</ul>
<p>综上, 可以通过单调性, <span class="math inline">\(O(1)\)</span>
判断祖先/查找所有子孙.</p>
<p><strong>证明</strong></p>
<p align="center">
<img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.webp&quot;" data-lazy-src="https://github.com/Blade-of-Mikasa/Img/blob/main/In_files/TimeStamp.jpg?raw=true" width="30%" />
</p>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc202/tasks/abc202_e?lang=en">E
- Count Descendants</a></p>
<p><strong>题意</strong></p>
<p>给个结点数 n 的树和 q 次询问. 每次询问给定结点 u 和深度 d, 问: u
的深度为 d 的子孙 (包括 u ) 有多少?</p>
<p><strong>思路</strong></p>
<p>按深度开桶, dfs 之后对每个通排序. 每次询问都可以在桶里二分(下界是
<code>&#123;u.in, u.in&#125;</code>, 上界是 <code>&#123;u.out, u.out&#125;</code>).
复杂度<span class="math inline">\(O(q\log n)\)</span>.</p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Mikasa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vi <span class="title">f</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vt&lt;vi&gt; <span class="title">son</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; f[i], son[f[i]].<span class="built_in">push_back</span>(i);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> tm = <span class="number">0</span>; <span class="comment">// timestamp</span></span><br><span class="line">    <span class="function">vi <span class="title">done</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">deep</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="function">vt&lt;pii&gt; <span class="title">ts</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    vt&lt;vt&lt;pii&gt;&gt; <span class="built_in">cntdeep</span>(n + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    ts[<span class="number">1</span>].first = ++tm;</span><br><span class="line">    deep[<span class="number">1</span>] = done[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    cntdeep[<span class="number">0</span>].<span class="built_in">push_back</span>(&#123;<span class="number">1</span>, <span class="number">2</span> * n&#125;);</span><br><span class="line">    function&lt;<span class="type">void</span>(<span class="type">int</span>)&gt; dfs = [&amp;](<span class="type">int</span> now) -&gt; <span class="type">void</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> s : son[now])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!done[s])</span><br><span class="line">            &#123;</span><br><span class="line">                ts[s].first = ++tm;</span><br><span class="line">                done[s] = <span class="number">1</span>, deep[s] = deep[now] + <span class="number">1</span>;</span><br><span class="line">                <span class="built_in">dfs</span>(s);</span><br><span class="line">                cntdeep[deep[s]].<span class="built_in">push_back</span>(ts[s]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ts[now].second = ++tm;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="built_in">sort</span>(cntdeep[i].<span class="built_in">begin</span>(), cntdeep[i].<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    cin &gt;&gt; q;</span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, d;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; d;</span><br><span class="line">        d++;</span><br><span class="line">        <span class="keyword">if</span>(deep[u] == d)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="number">1</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">auto</span> r = <span class="built_in">upper_bound</span>(cntdeep[d].<span class="built_in">begin</span>(), cntdeep[d].<span class="built_in">end</span>(), (pii)&#123;ts[u].second, ts[u].second&#125;);</span><br><span class="line">        <span class="keyword">auto</span> l = <span class="built_in">lower_bound</span>(cntdeep[d].<span class="built_in">begin</span>(), cntdeep[d].<span class="built_in">end</span>(), (pii)&#123;ts[u].first, ts[u].first&#125;);</span><br><span class="line">        cout &lt;&lt; (<span class="type">int</span>)(r - l) &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="图论">7. 图论</h2>
<h3 id="建图和遍历">7.1 建图和遍历</h3>
<p>n 个点，m 条边，点 u 的入度 <span
class="math inline">\(d^-(u)\)</span>，出度<span
class="math inline">\(d^+(u)\)</span>。</p>
<p><strong>建图</strong></p>
<p><strong>邻接矩阵 or 链式前向星</strong></p>
<p>略.</p>
<p><strong>邻接表</strong></p>
<p>使用最多, 使用一个支持动态增加元素的数据结构构成的数组，如
<code>vector&lt;int&gt; e[MAXN];</code>. <code>e [u]</code>存的是点 u
的所有出边信息（终点、边权等）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> from, to, w;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c = <span class="number">1</span>)</span><br><span class="line">    &#123;from = a, to = b, w = c;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;edge&gt; e[maxn];</span><br><span class="line"></span><br><span class="line"><span class="comment">//...</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(m --)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v&gt;&gt;w;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(<span class="built_in">edge</span>(u, v, w));</span><br><span class="line">        <span class="comment">//双向图加下面代码</span></span><br><span class="line">        <span class="comment">//e[v].push_back(edge(v, u, w));</span></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>查询是否存在从 u 到 v 的边：<span
class="math inline">\(O(d^+(u))\)</span>；若有多次查询，可以先排序再二分查找，<span
class="math inline">\(O(\log(d^+(u)))\)</span></p>
<p>遍历整张图：<span class="math inline">\(O(n+m)\)</span></p>
<p><strong>搜索</strong></p>
<p><strong>dfs</strong></p>
<p>判环</p>
<p><strong>bfs</strong></p>
<p><strong>lazy-tag 技术</strong></p>
<h3 id="最短路">7.2 最短路</h3>
<table>
<colgroup>
<col style="width: 26%" />
<col style="width: 16%" />
<col style="width: 29%" />
<col style="width: 27%" />
</colgroup>
<thead>
<tr>
<th style="text-align: center;">应用</th>
<th style="text-align: center;">边权条件</th>
<th style="text-align: center;">算法</th>
<th style="text-align: center;">时间复杂度</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align: center;"><strong>单点到单点</strong></td>
<td style="text-align: center;">无权</td>
<td style="text-align: center;">贪心最优搜索</td>
<td style="text-align: center;"><span class="math inline">\(O(m +
n)\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><strong>单点到所有点</strong></td>
<td style="text-align: center;">无权</td>
<td style="text-align: center;">BFS</td>
<td style="text-align: center;"><span class="math inline">\(O(m +
n)\)</span></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">非负</td>
<td style="text-align: center;">Dijkstra</td>
<td style="text-align: center;"><span class="math inline">\(O((m +
n)\log(m + n))\)</span></td>
</tr>
<tr>
<td style="text-align: center;"></td>
<td style="text-align: center;">—</td>
<td style="text-align: center;">SPFA</td>
<td style="text-align: center;"><span
class="math inline">\(O(mn)\)</span></td>
</tr>
<tr>
<td style="text-align: center;"><strong>所有点之间</strong></td>
<td style="text-align: center;">无负环</td>
<td style="text-align: center;">Floyd-Warshall</td>
<td style="text-align: center;"><span class="math inline">\(O(n ^
3)\)</span></td>
</tr>
</tbody>
</table>
<p><strong>dijkstra</strong></p>
<p>复杂度 <span class="math inline">\(O((m + n)\log (m +
n))\)</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span>&#123;</span><br><span class="line">    <span class="type">int</span> to, v;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> a, <span class="type">int</span> b)&#123; </span><br><span class="line">		to = a, v = b; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;vector&lt;edge&gt;&gt; <span class="built_in">e</span>(n + <span class="number">10</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">dijk</span><span class="params">(<span class="type">int</span> n, <span class="type">int</span> m, <span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dis</span><span class="params">(n + <span class="number">10</span>, INF)</span>, <span class="title">done</span><span class="params">(n + <span class="number">10</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; q;<span class="comment">//求最近点</span></span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;dis[s], s&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [nowdis, now] = q.<span class="built_in">top</span>();<span class="comment">//访问最近点</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(done[now])    <span class="keyword">continue</span>;</span><br><span class="line">        done[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next: e[now])<span class="comment">//更新距离, 加入队列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [to, v] = next;</span><br><span class="line">            <span class="keyword">if</span>(dis[to] &gt; nowdis + v)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = nowdis + v;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dis[to], to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m, s;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m &gt;&gt; s;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> u, v, w;</span><br><span class="line">        cin &gt;&gt; u &gt;&gt; v &gt;&gt; w;</span><br><span class="line">        e[u].<span class="built_in">push_back</span>(&#123;v, w&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> dis = <span class="built_in">dijk</span>(n, m, s);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">        cout &lt;&lt; dis[i] &lt;&lt; <span class="string">&#x27; &#x27;</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>function 封装</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">function&lt;vector&lt;<span class="type">int</span>&gt;(<span class="type">int</span>)&gt; dijk = [&amp;](<span class="type">int</span> s = <span class="number">1</span>) -&gt; vector&lt;<span class="type">int</span>&gt;</span><br><span class="line">&#123;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; <span class="built_in">dis</span>(n + <span class="number">10</span>, INF), <span class="built_in">done</span>(n + <span class="number">10</span>, <span class="number">0</span>);</span><br><span class="line">    priority_queue&lt;pii, vector&lt;pii&gt;, greater&lt;&gt;&gt; q; <span class="comment">// 求最近点</span></span><br><span class="line">    dis[s] = <span class="number">0</span>;</span><br><span class="line">    q.<span class="built_in">push</span>(&#123;dis[s], s&#125;);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [nowdis, now] = q.<span class="built_in">top</span>(); <span class="comment">// 访问最近点</span></span><br><span class="line">        q.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span> (done[now])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        done[now] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> next : e[now]) <span class="comment">// 更新距离, 加入队列</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> [from, to, w] = next;</span><br><span class="line">            <span class="keyword">if</span> (dis[to] &gt; nowdis + w)</span><br><span class="line">            &#123;</span><br><span class="line">                dis[to] = nowdis + w;</span><br><span class="line">                q.<span class="built_in">push</span>(&#123;dis[to], to&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dis;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>有限制的最短路</strong></p>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/78309/H">H-To the Moon,
Finding Paradise_华中农业大学第十三届程序设计竞赛（同步赛）</a></p>
<p>每个点都有代价, 并且只能选小于 y 的边. 问: 从起点到终点的最小代价小于
c 时, y 最小为多少?</p>
<p>二分答案 + 可选性 dijk.</p>
<p><strong>分层图最短路</strong></p>
<p>分层图问题难在建图</p>
<p><strong>加速点的最短路</strong></p>
<p>起始节点的实图和虚图相连, 加速点的实图单向连接虚图中的邻居节点</p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2014/problem/E">Problem - E -
Codeforces</a></p>
<p>图中有 h 个节点有马, 骑马后速度加倍, 两个人从 1 和 n 出发,
问相遇的最短时间(只能在节点上相遇)</p>
<p><a
target="_blank" rel="noopener" href="https://codeforces.com/contest/2014/submission/282790204">Submission
#282790204 - Codeforces</a></p>
<p><strong>多层不同权值图</strong></p>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/problem/26257">小雨坐地铁
(nowcoder.com)</a></p>
<p>建 m + 1层图, 其中第 1 层作为中转站, 这样能避免 (m + 1)! 的接图操作,
只要每个图与第一层相连即可</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4568">P4568
飞行路线</a></p>
<p>不同层之间单向链接, 否则上下横跳可以 0 权到达所有点</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/178413869">记录详情</a></p>
<p><a target="_blank" rel="noopener" href="https://ac.nowcoder.com/acm/contest/95480/L">L-小 S
的魔法_华中农业大学第十四届程序设计竞赛（新生赛）同步赛</a></p>
<h3 id="最小生成树">7.3 最小生成树</h3>
<p>反证: 假如 u 到 v 不选最短边 a, 那么一定会选其他边 b 使得两个点相连.
此时连上最短边 a, 构成环, 然后断开 b. 也一定是一颗生成树,
而且一定不比刚才的更不优. 故而得证.</p>
<p><strong>克鲁斯卡尔</strong></p>
<p><span class="math inline">\(O(m\log m)\)</span>. 升序遍历边,
每次如果不在同一个连通块上就连结.</p>
<p><strong>prim</strong></p>
<p>有朴素做法 <span class="math inline">\(O(n^2)\)</span> 和堆优化 <span
class="math inline">\(O(m\log n)\)</span> 两种做法.
完全图时<strong>朴素做法</strong>更优.</p>
<p>暂时不会.</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P4047">P4047
部落划分</a></p>
<p><strong>虚图</strong></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1245/D">Problem -
1245D - Codeforces</a></p>
<p><strong>题意</strong></p>
<p>给 n <span class="math inline">\((n\leq 2\times10^3)\)</span> 个城市,
分布在二维坐标上. 给城市 i 配置发电厂要花费 <span
class="math inline">\(c_i\)</span>, 连结城市 i, j 的电路花费 <span
class="math inline">\((k_i + k_j)\times (|\Delta x_{ij}| + |\Delta
y_{ij}|)\)</span>.</p>
<p>问: 要使得所有城市都供电, 最少花费多少?</p>
<p><strong>思路</strong></p>
<p>设一个虚结点表示 "供电的城市", 城市 i 到虚结点的距离为 <span
class="math inline">\(c_i\)</span>. 然后跑一遍最小生成树即可.</p>
<h3 id="ps-神秘结论-1">PS 神秘结论</h3>
<h4 id="染色问题">染色问题</h4>
<p>出入度均为 1 的 n 阶环, 对边的两点染色, 要求最后所有点都被染色.
方案数为: <span class="math inline">\(f(n) = f(n - 1) + f(n
-2)\)</span></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/AT_abc247_f">ABC247F
Cards</a></p>
<h4 id="拉姆齐定理">拉姆齐定理</h4>
<p>在任何一个完全图中，所有边用两种颜色中的一种着色后，必然存在一个单色的完全子图.</p>
<p><span class="math inline">\(R(s,t)\)</span>
表示在一个完全图中，边用红色和蓝色着色后，子图中必然存在一个以红色为边的
<span class="math inline">\(s\)</span> 阶完全图或以蓝色为边的 <span
class="math inline">\(t\)</span> 阶完全图.</p>
<p>最著名的 <span class="math inline">\(R(3, 3) =
6\)</span>，这意味着任意一个阶数大于等于 6 的图,
要么<strong>原图上存在三元环, 要么补图上存在三元环</strong>.</p>
<p><a
target="_blank" rel="noopener" href="https://codeforces.com/group/BJlsDCvlJO/contest/589198/problem/E">Problem
- E - Codeforces</a></p>
<p>给你一个长度为 <span class="math inline">\(n\)</span> 的数组 <span
class="math inline">\(a\)</span> , 处理 <span
class="math inline">\(q\)</span> 个查询。每个查询由两个整数 <span
class="math inline">\(i\)</span> , <span
class="math inline">\(x\)</span> 组成, 赋值 <span
class="math inline">\(a_i=x\)</span> ，在每次查询中更新 <span
class="math inline">\(a_i\)</span> 的值后，应该确定是否存在三元组 <span
class="math inline">\((i,j,k)\)</span> 满足下面其一：</p>
<ul>
<li><span class="math inline">\(\gcd(a_i,a_j)=1 \land \gcd(a_i,a_k)=1
\land \gcd(a_j,a_k) = 1\)</span></li>
<li><span class="math inline">\(\gcd(a_i,a_j)\ne 1 \land
\gcd(a_i,a_k)\ne 1 \land \gcd(a_j,a_k) \ne 1\)</span></li>
</ul>
<p><strong>题解</strong></p>
<p>任意枚举 6 个点, 必然能找到一种三元组</p>
<h2 id="计算几何">8. 计算几何</h2>
<p>由于精度问题，需要一个相等判断函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">const</span> <span class="type">double</span> pi = <span class="built_in">acos</span>(<span class="number">-1.0</span>);</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> eps = <span class="number">1e-8</span>;</span><br></pre></td></tr></table></figure>
<h2 id="杂项">9. 杂项</h2>
<h4 id="离线">离线</h4>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">question</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, id;</span><br><span class="line">    <span class="built_in">question</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) &#123; x = a, y = b, id = c; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> question &amp;other) <span class="type">const</span> &#123; <span class="keyword">return</span> y &lt; other.y; &#125; <span class="comment">// 因题而异</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="根号分治">根号分治</h4>
<p>这是一种思想.</p>
<ul>
<li><p>发现当 n 比较大时满足一定规律, n 比较小时能暴力.</p></li>
<li><p>当变量 x 和变量 y 乘积定值, 且既有 <span
class="math inline">\(O(f(x))\)</span> 做法又有 <span
class="math inline">\(O(g(y))\)</span> 做法时,
常用根号分治平衡复杂度.</p></li>
<li><p>给个矩阵, 每次查询一些行列不对称的信息.</p></li>
</ul>
<p><a
target="_blank" rel="noopener" href="https://www.luogu.com.cn/article/5gtqzd4a">暴力美学——浅谈根号分治专栏</a></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/777/C">Problem -
777C - Codeforces</a></p>
<p><strong>题意</strong></p>
<p>给一个 <span class="math inline">\(n\times m\)</span> 的矩阵 a 和
k.</p>
<p><span class="math inline">\(k\)</span> 次询问, 每次给出 <span
class="math inline">\(l, r\)</span>, 问: 假如只保留矩阵的第 <span
class="math inline">\(l\to r\)</span> 行, 是否存在单调不减的列.</p>
<p><strong>思路</strong></p>
<p>注意到是矩阵并且只问一个维度的信息, 考虑根号分治 (记 <span
class="math inline">\(sq = \sqrt{nm}\)</span>).</p>
<ul>
<li>当 <span class="math inline">\(m\leq sq\leq n\)</span> 时. 预处理
<span class="math inline">\(ord(i, j)\)</span>, 记录 <span
class="math inline">\(a_{i, j}\)</span> 在矩阵第 <span
class="math inline">\(i\)</span> 列中的第 <span
class="math inline">\(ord(i, j)\)</span> 个单调不减序列中.
然后每次询问遍历所有 <span class="math inline">\(m\)</span>, 看是否有
<span class="math inline">\(ord(l, j)=ord(r, j)\)</span>. 复杂度 <span
class="math inline">\(O(nm^2)\)</span>.</li>
<li>当 <span class="math inline">\(n\leq sq\leq m\)</span> 时.
预处理对每一列, 所有子数组是否单调不减.</li>
</ul>
<p>总复杂度 <span class="math inline">\(O(\min(n^2m,
nm^2))\)</span>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Mikasa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="function">vt <span class="title">a</span><span class="params">(n + <span class="number">1</span>, vi(m + <span class="number">1</span>, <span class="number">0</span>))</span>, <span class="title">ord</span><span class="params">(n + <span class="number">1</span>, vi(m + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            cin &gt;&gt; a[i][j];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> now = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            ord[i][j] = ((a[i][j] &gt;= a[i - <span class="number">1</span>][j]) ? now : (++now));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    vt&lt;vi&gt; check;</span><br><span class="line">    <span class="keyword">if</span> (n &lt;= m)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">vt <span class="title">dp</span><span class="params">(n + <span class="number">1</span>, vi(n + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> now = <span class="number">1</span>; now &lt;= m; ++now)</span><br><span class="line">                    <span class="keyword">if</span> (ord[i][now] == ord[j][now])</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[i][j] = <span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">        check = dp;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> k;</span><br><span class="line">    cin &gt;&gt; k;</span><br><span class="line">    <span class="keyword">while</span> (k--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> l, r;</span><br><span class="line">        cin &gt;&gt; l &gt;&gt; r;</span><br><span class="line">        <span class="keyword">if</span> (n &lt;= m)</span><br><span class="line">            check[l][r] ? yes : no;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">bool</span> have = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= m; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ord[l][j] == ord[r][j])</span><br><span class="line">                &#123;</span><br><span class="line">                    have = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            have ? yes : no;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1619/H">Problem -
1619H - Codeforces</a></p>
<p><strong>题意</strong></p>
<p>给定由 <span class="math inline">\(1 \sim n\)</span> 构成的排列 <span
class="math inline">\(p\)</span>，有两种操作（<span
class="math inline">\(1 \le n,q \le 10^{5}\)</span>）:</p>
<ul>
<li><p><code>1 x y</code>：交换 <span
class="math inline">\(p_{x}\)</span> 和 <span
class="math inline">\(p_{y}\)</span>。</p></li>
<li><p><code>2 i k</code>：给出 <span class="math inline">\(i\)</span>
的初始值，令 <span class="math inline">\(i \gets p_{i}\)</span> 执行
<span class="math inline">\(k\)</span> 次，最后输出 <span
class="math inline">\(i\)</span>.</p></li>
</ul>
<p><strong>思路</strong></p>
<p><span class="math inline">\(i := p_i\)</span> 经典转图.
每个连通块上找 "点 i 往后 <span class="math inline">\(\sqrt{n}\)</span>
的点", 预处理可以 <span class="math inline">\(O(n\sqrt{n})\)</span>
求出; 假如不带修, 那么可以分块跑 k, 一共 <span
class="math inline">\(O((n + q){\sqrt{n}})\)</span> 解决.</p>
<p>考虑怎么处理修点, 不难发现也可以 <span
class="math inline">\(O(\sqrt{n})\)</span> 解决. 显然交换 x 和 y 后,
只有 x 前面的 <span class="math inline">\(\sqrt{n}\)</span> 个和后面
<span class="math inline">\(\sqrt{n}\)</span> 个点会受影响, y 同理.
所以暴力维护就可以.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mikasa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vi <span class="title">jump</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vt&lt;pii&gt; <span class="title">p</span><span class="params">(n + <span class="number">1</span>)</span></span>; <span class="comment">// first 前进, second 后退</span></span><br><span class="line">    <span class="type">int</span> len = <span class="built_in">sqrt</span>(n), block = <span class="built_in">sqrt</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (n - len * len)    block++;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; p[i].first;</span><br><span class="line">        p[p[i].first].second = i;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vt&lt;<span class="type">bool</span>&gt; <span class="title">done</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (done[i])</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> cnt = len, ed = i, now = i;</span><br><span class="line">        <span class="keyword">while</span> (cnt--)</span><br><span class="line">            ed = p[ed].first;</span><br><span class="line">        <span class="keyword">while</span> (done[now] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            done[now] = <span class="number">1</span>;</span><br><span class="line">            jump[now] = ed;</span><br><span class="line">            ed = p[ed].first, now = p[now].first;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> update = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">void</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> cnt = len, now = x, nowp = x;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len; ++i)</span><br><span class="line">            nowp = p[nowp].first;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= len * <span class="number">2</span>; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            jump[now] = nowp;</span><br><span class="line">            nowp = p[nowp].second, now = p[now].second;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op;</span><br><span class="line">        cin &gt;&gt; op;</span><br><span class="line">        <span class="keyword">if</span> (op == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> x, y;</span><br><span class="line">            cin &gt;&gt; x &gt;&gt; y;</span><br><span class="line">            p[p[x].first].second = y, p[p[y].first].second = x;</span><br><span class="line">            <span class="built_in">swap</span>(p[x].first, p[y].first);</span><br><span class="line">            <span class="built_in">update</span>(x), <span class="built_in">update</span>(y);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (op == <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> now, k;</span><br><span class="line">            cin &gt;&gt; now &gt;&gt; k;</span><br><span class="line">            <span class="keyword">while</span> (k &gt;= len)</span><br><span class="line">            &#123;</span><br><span class="line">                now = jump[now];</span><br><span class="line">                k -= len;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= k; ++i)</span><br><span class="line">                now = p[now].first;</span><br><span class="line">            cout &lt;&lt; now &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/103/D">Problem -
103D - Codeforces</a></p>
<p><strong>题意</strong></p>
<p>给一个长度为 n 的序列 a, 有 m 次询问(<span class="math inline">\(n,
m≤3\times 10^5\)</span>).</p>
<p>每次询问给出 t, k, 问: <span class="math inline">\(\sum_{i = 0} a_{t
+ ik}\)</span></p>
<p><strong>思路</strong></p>
<p>这类一步跳多少的题一般都是根号分治。</p>
<p>暴力求平均复杂度 <span class="math inline">\(O(n\sqrt{m})\)</span>,
但是<strong>最坏情况 <span
class="math inline">\(O(nm)\)</span></strong>. 想到前缀和,
但是如果对每个 k 都求一次所有初始点的前缀和, 复杂度 <span
class="math inline">\(O(n^2)\)</span>.</p>
<p>注意到当 k 较大时, 不用预处理所有情况, 暴力计算就可以, 每次复杂度
<span class="math inline">\(O({n\over k})\)</span>.</p>
<p>设分界点是 p:</p>
<ul>
<li>当 <span class="math inline">\(k \leq p\)</span> 时,
预处理出所有初始点的前缀和, 复杂度 <span
class="math inline">\(O(np)\)</span>.</li>
<li>当 <span class="math inline">\(k &gt; p\)</span> 时, 暴力求解,
复杂度 <span class="math inline">\(O({mn\over p})\)</span>.</li>
</ul>
<p>那么最坏复杂度 <span class="math inline">\(O(np + {mn\over
p})\)</span>, p 是分界点. 易知 p 取 <span
class="math inline">\(\sqrt{m}\)</span> 时最优, 所以最坏复杂度 <span
class="math inline">\(O(n\sqrt{m})\)</span>.</p>
<p>PS: 有点反直觉, 因为貌似不分类直接暴力的复杂度也不高, 但是假如所有 k
都很小时, 那么每次暴力都是 <span class="math inline">\(O({n\over k})
\simeq O(n)\)</span> 的.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">question</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> x, y, id;</span><br><span class="line">    <span class="built_in">question</span>(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c) &#123; x = a, y = b, id = c; &#125;</span><br><span class="line">    <span class="type">bool</span> <span class="keyword">operator</span>&lt;(<span class="type">const</span> question &amp;other) <span class="type">const</span> &#123; <span class="keyword">return</span> y &lt; other.y; &#125; <span class="comment">// 因题而异</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mikasa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, m;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vi <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    cin &gt;&gt; a &gt;&gt; m;</span><br><span class="line">    <span class="function">vi <span class="title">ans</span><span class="params">(m + <span class="number">1</span>)</span></span>;</span><br><span class="line">    vt&lt;question&gt; que;</span><br><span class="line">    <span class="type">int</span> p = <span class="built_in">sqrt</span>(m);</span><br><span class="line"></span><br><span class="line">    que.<span class="built_in">push_back</span>(&#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> t, k;</span><br><span class="line">        cin &gt;&gt; t &gt;&gt; k;</span><br><span class="line">        que.<span class="built_in">push_back</span>(&#123;t, k, i&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vt&lt;vi&gt; <span class="title">cnt</span><span class="params">(p + <span class="number">10</span>)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">auto</span> [t, k, now] = que[i];</span><br><span class="line">        <span class="keyword">if</span> (que[i].y &lt;= p)</span><br><span class="line">            cnt[k].<span class="built_in">push_back</span>(now);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = t; j &lt;= n; j += k)</span><br><span class="line">                ans[now] += a[j];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k = <span class="number">1</span>; k &lt; cnt.<span class="built_in">size</span>(); ++k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (cnt[k].<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="function">vi <span class="title">s</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            s[i] = (i &gt; k) ? (s[i - k] + a[i]) : a[i];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> id : cnt[k])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> t = que[id].x, k = que[id].y;</span><br><span class="line">            <span class="type">int</span> bg = <span class="built_in">max</span>(<span class="number">0ll</span>, que[id].x - k), ed = ((n - t) / k) * k + t;</span><br><span class="line">            ans[id] = s[ed] - s[bg];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= m; ++i)</span><br><span class="line">        cout &lt;&lt; ans[i] &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="带权二分">带权二分</h4>
<p><strong>解释:</strong></p>
<p>定义 <span class="math inline">\(f(x)\)</span> : 只能操作 <span
class="math inline">\(x\)</span> 次时, 收益的最大值.</p>
<p>这类题目基本都具有凹凸性。如果你要选第一个物品，第一次肯定会选当前能选择的最大值。</p>
<p>证明:
首先，因为每次选择之后，限制肯定更严。如果第二次选择物品收益的比第一次大。因为第一次限制比第二次小，所以在第一次选择的时候肯定也可以选择第二次的。与第一次选择了最优价值矛盾。所以我们证明了
<span class="math inline">\(f(x) - f(x - 1) \leq f(x + 1) -
f(x)\)</span>, 也就是说, <span class="math inline">\(f(x)\)</span>
是凸函数。故而斜率具有单调性.</p>
<p>已知斜率 <span class="math inline">\(k\)</span>, 要求出切点的 <span
class="math inline">\(x\)</span>. 对于给定的 <span
class="math inline">\(k\)</span> 和 <span
class="math inline">\(x\)</span>, 只有相切时, 斜率为 k 的直线与 <span
class="math inline">\(y\)</span> 轴截距 <span
class="math inline">\(g(x)\)</span> 最大 (画图易证) . 故而 <span
class="math inline">\(s.t.\max g(x)\)</span> 时就是要求的切点. 也就是说,
对于给定 <span class="math inline">\(k\)</span>, <span
class="math inline">\(\max g(x)\)</span> 的条件就是 <span
class="math inline">\(x\)</span> 时的条件.</p>
<p>所以我们利用 <span class="math inline">\(g(x)\)</span> 来求出此时的
<span class="math inline">\(x\)</span>, 并且保证复杂度较低. 要使得 <span
class="math inline">\(g(x)\)</span> 最大 , 根据定义 <span
class="math inline">\(g(x) = f(x) - kx\)</span> (注意 <span
class="math inline">\(x\)</span> 是未知的), 则有 <span
class="math inline">\(s.t.\max g(x)\)</span> 等价于:
<strong>操作次数无最大限制, 但是每操作一次都会惩罚 k
时的最大收益.</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P6821">P6821 Tanie
linie</a></p>
<p>板子题. 前面思考过程的省略, 直接解决:</p>
<p>取的次数无最大限制, 但是每取一段都会惩罚 k 的最大收益.</p>
<p>这个问题可以 <span class="math inline">\(O(n)\)</span>
解决(目前还不会), 所以总复杂度 <span class="math inline">\(O(n\log
V)\)</span>.</p>
<h4 id="分数规划">01分数规划</h4>
<h4 id="扫描线">扫描线</h4>
<p>给 <span class="math inline">\(n\)</span> 个线段, 问是否有一个区间,
使得其上覆盖有至少 k 条线段(或其他信息).</p>
<p>用一个差分数组 cnt 记录信息, 对线段 <span
class="math inline">\(\text{seg}_i = [l_i, r_i]\)</span>, 有: <span
class="math inline">\(cnt[l_i]\)</span> +1, <span
class="math inline">\(cnt[r_i + 1]\)</span> - 1</p>
<p>从前到后遍历求 cnt 的前缀和, 和 k 比较即可. 复杂度 <span
class="math inline">\(O(n\log n)\)</span>.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n, m, k;</span><br><span class="line"><span class="type">int</span> x[maxn], hp[maxn];</span><br><span class="line">vector&lt;pii&gt; v;</span><br><span class="line">vector&lt;<span class="type">int</span>&gt; s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">f</span><span class="params">(<span class="type">int</span> ans)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    v.<span class="built_in">clear</span>();</span><br><span class="line">    s.<span class="built_in">clear</span>();</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(n * <span class="number">2</span> + <span class="number">5</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(m * ans &lt; hp[i]) <span class="keyword">continue</span>;</span><br><span class="line">        <span class="type">int</span> eak = (hp[i] + ans - <span class="number">1</span>) / ans;</span><br><span class="line">        <span class="type">int</span> d = m - eak;</span><br><span class="line">        pii l = &#123;<span class="built_in">max</span>((<span class="type">int</span>)<span class="number">0</span>, x[i] - d), <span class="number">1</span>&#125;;</span><br><span class="line">        pii r = &#123;<span class="built_in">min</span>((<span class="type">int</span>)inf, x[i] + d), <span class="number">0</span>&#125;;</span><br><span class="line">        v.<span class="built_in">push_back</span>(l);</span><br><span class="line">        v.<span class="built_in">push_back</span>(r);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(v.<span class="built_in">begin</span>(), v.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; v.<span class="built_in">size</span>(); ++ i)</span><br><span class="line">        s.<span class="built_in">push_back</span>(v[i].first);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">unique</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> p:v)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">lower_bound</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>(), p.first) - s.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(p.second)  cnt[i] ++;</span><br><span class="line">        <span class="keyword">else</span> cnt[i + <span class="number">1</span>]--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); ++ i)</span><br><span class="line">    &#123;</span><br><span class="line">        t += cnt[i];        </span><br><span class="line">        <span class="keyword">if</span>(t &gt;= k) </span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="定积分">定积分</h4>
<p><strong>自适应辛普森</strong></p>
<p>​
辛普森法的思想是将被积区间分为若干小段，每段套用二次函数的积分公式进行计算；为了在保证精度的前提下改进速度，我们每次判断当前段和二次函数的相似程度，如果足够相似的话就直接代入公式计算，否则将当前段分割成左右两段递归求解，这就是自适应。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">double</span> <span class="title">simpson</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">return</span> (r - l) * (<span class="built_in">f</span>(l) + <span class="number">4</span> * <span class="built_in">f</span>(mid) + <span class="built_in">f</span>(r)) / <span class="number">6</span>;  <span class="comment">// 辛普森公式</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">asr</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r, <span class="type">double</span> eps, <span class="type">double</span> ans, <span class="type">int</span> step)</span> </span>&#123;</span><br><span class="line">    <span class="type">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">    <span class="type">double</span> fl = <span class="built_in">simpson</span>(l, mid), fr = <span class="built_in">simpson</span>(mid, r);</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 足够相似的话就直接返回</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">abs</span>(fl + fr - ans) &lt;= <span class="number">15</span> * eps &amp;&amp; step &lt; <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> fl + fr + (fl + fr - ans) / <span class="number">15</span>;  </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 否则分割成两段递归求解</span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">asr</span>(l, mid, eps / <span class="number">2</span>, fl, step - <span class="number">1</span>) + <span class="built_in">asr</span>(mid, r, eps / <span class="number">2</span>, fr, step - <span class="number">1</span>); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">double</span> <span class="title">calculus</span><span class="params">(<span class="type">double</span> l, <span class="type">double</span> r, <span class="type">double</span> eps)</span> </span>&#123; <span class="keyword">return</span> <span class="built_in">asr</span>(l, r, eps, <span class="built_in">simpson</span>(l, r), <span class="number">12</span>); &#125;</span><br></pre></td></tr></table></figure>
<h4 id="异或哈希">异或哈希</h4>
<p>利用异或的性质和哈希降低冲突的原理，可以快速找到一个组合是否出现</p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/1175/problem/F">Problem - F -
Codeforces</a></p>
<p>异或 hash + 类双指针</p>
<p>注意到排列中一定要有 1, 遍历所有 <span class="math inline">\(a[ i ] =
1\)</span> 的位置. 每次从 <span class="math inline">\(i\)</span>
开始向后找, 记录 <strong><span class="math inline">\(i\to j\)</span>
最大值 <span class="math inline">\(maxa\)</span></strong>,
注意到假如一个序列是以第 <span class="math inline">\(j\)</span>
位结束并且包含第 <span class="math inline">\(i\)</span> 位的, 那么其长度
<span class="math inline">\(len\)</span> 必然等于 <span
class="math inline">\(maxa\)</span>, 且不能大于 <span
class="math inline">\(j - i + 1\)</span>. 也就是说,
<strong>这个排列必然是从第 <span class="math inline">\(j - len\)</span>
位到第 <span class="math inline">\(j\)</span> 位的.</strong></p>
<p>利用 <span class="math inline">\(a\)</span>
的哈希前缀以及类桶的哈希前缀 <span class="math inline">\(s\)</span>
就可以 <span class="math inline">\(O(1)\)</span> 判断. 然后倒序来一次,
再注意单独的 1.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Mikasa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    <span class="function">vt&lt;<span class="type">int</span>&gt; <span class="title">a</span><span class="params">(n + <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="function">vt&lt;ull&gt; <span class="title">rd</span><span class="params">(n + <span class="number">1</span>)</span>, <span class="title">s</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    cin &gt;&gt; a;</span><br><span class="line">    <span class="type">int</span> cnt1 = <span class="number">0</span>, ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        rd[i] = <span class="built_in">rnd</span>();</span><br><span class="line">        s[i] = s[i - <span class="number">1</span>] ^ rd[i];</span><br><span class="line">        <span class="keyword">if</span> (a[i] == <span class="number">1</span>)</span><br><span class="line">            cnt1++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> f = [&amp;]() -&gt; <span class="type">int</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>, len = <span class="number">0</span>;</span><br><span class="line">        <span class="function">vt&lt;ull&gt; <span class="title">h</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            h[i] = h[i - <span class="number">1</span>] ^ rd[a[i]];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">1</span>, r = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (a[l] != <span class="number">1</span>)    l++;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (l &lt;= n &amp;&amp; r &lt;= n)</span><br><span class="line">        &#123;</span><br><span class="line">            len = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span> (r = l + <span class="number">1</span>; r &lt;= n; ++r)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (a[r] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    l = r;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                len = <span class="built_in">max</span>(len, a[r]);</span><br><span class="line">                <span class="keyword">if</span> (r - len &lt; <span class="number">0</span> || l + len &lt; r)    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[len] == (h[r] ^ h[r - len]))    ans++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    ans += <span class="built_in">f</span>();</span><br><span class="line">    <span class="built_in">reverse</span>(a.<span class="built_in">begin</span>() + <span class="number">1</span>, a.<span class="built_in">end</span>());</span><br><span class="line">    ans += <span class="built_in">f</span>();</span><br><span class="line">    cout &lt;&lt; ans + cnt1 &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="神秘结论">神秘结论</h4>
<p><strong>二元整数线性规划</strong></p>
<p>已知线性整数规划; <span class="math display">\[
s.t.\begin{cases}
p + 2q\leq n\\
2p + q\leq m\\
\end{cases}\\
\max p + q = \max (\lceil {n + m\over 3}\rceil, \lceil{n\over 2}\rceil,
\lceil{m \over 2}\rceil)
\]</span></p>
<p>拓展: <span class="math display">\[
s.t.\begin{cases}
a p + b q\leq n\\
b p + a q\leq m\\
\end{cases}\\
\]</span></p>
<p><span class="math display">\[
\max p + q = \max(\lceil{n + m\over a + b}\rceil, \lceil{n\over \max
a,b}\rceil, \lceil{m\over \max a,b}\rceil)
\]</span></p>
<h4 id="骗分算法">骗分算法</h4>
<p><strong>卡时</strong></p>
<p><strong>注意: 对 XCPC 无用</strong></p>
<p>有些题目我们想不到正解就只能暴搜，但是此类方法一般时间复杂度较高，此时我们需要进行卡时</p>
<p>通俗来讲就是进行时间限制，让程序在达到这个时间后立马退出，输出当前最优方案，<strong>或许</strong>能碰中正确答案(or
获得更多步骤分)</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>((<span class="type">double</span>)<span class="built_in">clock</span>() / CLOCKS_PER_SEC &gt; <span class="number">0.9</span>)</span><br><span class="line">&#123;       </span><br><span class="line">    <span class="comment">//output</span></span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>常见的卡时</strong>:</p>
<p>无解输出 <code>-1</code> / 答案种类很少(例如判断奇偶…)</p>
<p><strong>实例</strong></p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/problem/P1874">P1874
快速求和</a></p>
<p>无卡时:</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/191171726">记录详情</a></p>
<p>卡时:</p>
<p><a target="_blank" rel="noopener" href="https://www.luogu.com.cn/record/191171725">记录详情</a></p>
<p><strong>随机化</strong></p>
<p>随机数调用 <code>mt19937 rnd(time(0));</code></p>
<p>取 [l, r] 随机数: <code>rnd() % (r - l + 1) + l</code></p>
<p><strong>随机打乱数组</strong></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">mt19937 <span class="title">rnd</span><span class="params">(time(<span class="number">0</span>))</span></span>;</span><br><span class="line"><span class="built_in">shuffle</span>(a.<span class="built_in">begin</span>(), a.<span class="built_in">end</span>(), rnd);</span><br></pre></td></tr></table></figure>
<h2 id="良好性质-trick">10. 良好性质 &amp; Trick</h2>
<h4 id="mex-问题">mex 问题</h4>
<p><strong>性质</strong></p>
<ul>
<li><p><span class="math inline">\(\text{mex}(s)\leq
s.size\)</span></p></li>
<li><p>单调性: 左区间是 <span class="math inline">\(x - \sum{|a_i&lt;x|}
&lt;1\)</span> 且 <span class="math inline">\((x - \sum{|a_i&lt;x|} = 1
\and \not\exist a_i =x)\)</span>, <span
class="math inline">\(\text{mex}(x)\)</span>是右区间的左端点.</p></li>
</ul>
<p><strong>应用</strong></p>
<p>设集合 <span class="math inline">\(s\)</span> 初始为 <span
class="math inline">\(\{0\}\)</span>。对于从 <span
class="math inline">\(1\)</span> 到 <span
class="math inline">\(n\)</span> 的每个整数 <span
class="math inline">\(d（n \le 10^5\)</span>）, 依次进行如下操作：</p>
<ol type="1">
<li>令 <span class="math inline">\(a = \text{mex}(s)\)</span>, <span
class="math inline">\(b = a + d - 1\)</span>；</li>
<li>将 <span class="math inline">\(a\)</span> 与 <span
class="math inline">\(b\)</span> 加入集合 <span
class="math inline">\(s\)</span> 中。</li>
</ol>
<p>求经过所有操作后 <span class="math inline">\(\text{mex}(s)\)</span>
。</p>
<p><strong>带有 tag 的题</strong></p>
<h4 id="排列问题">排列问题</h4>
<p><strong>性质</strong></p>
<ul>
<li><span class="math inline">\(i\to p_i\)</span> 是满射</li>
</ul>
<p><strong>应用</strong></p>
<p><span class="math inline">\(a_i := a_{p_i}\)</span> 问题:
等价于一个各个点出入度均为1的图, 常结合并查集查找连通块.</p>
<p>两个排列的 <span class="math inline">\(lcs\)</span> 可以转化成 <span
class="math inline">\(lis\)</span>.</p>
<p>快速判断排列可以 <span class="math inline">\(o(n)\)</span>
异或哈希.</p>
<p>结合律运算下交换顺序有一定不等式性质.</p>
<p><strong>带有 tag 的题</strong></p>
<p><a
target="_blank" rel="noopener" href="https://codeforces.com/group/BJlsDCvlJO/contest/589198/problem/A">Problem
- A - Codeforces</a></p>
<p>证明: 如果<span class="math inline">\({\oplus}_1^k i = m\)</span>,
那么交换 <span class="math inline">\(k\)</span> 和 <span
class="math inline">\(k + 1\)</span> 一定不为 <span
class="math inline">\(m\)</span>.</p>
<p>易证.</p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2071/problem/B">Problem - B -
Codeforces</a></p>
<p>证明: 如果<span class="math inline">\(\sum_1^ki\)</span>是完全平方数,
那么交换 <span class="math inline">\(k\)</span> 和 <span
class="math inline">\(k + 1\)</span> 一定不出现完全平方数.</p>
<p>可以反证.</p>
<h4 id="异或问题">异或问题</h4>
<p><strong>性质</strong></p>
<ul>
<li>位运算很自然的契合<strong>贪心</strong>, 相同数量的 1,
放到高位优于放到低位. 所以假如要尽可能大的答案, 一般从高位到低位构造 or
查询.</li>
<li>异或具有交换律, 无关顺序(无后效性), 可以从集合的角度考虑.</li>
<li>异或是不进位加法, 有比较紧的不等式.</li>
<li>异或可视为伪随机分布, 故而可以估计概率, 用随机化算法.</li>
<li>异或有相消性, 这个用法很巧妙.</li>
<li>异或运算时不同位相互独立, 可以看成向量, 用线代的视角处理
(线性基)</li>
</ul>
<p><strong>应用</strong></p>
<p>异或哈希</p>
<p>k 进制异或</p>
<p>01 字典树 (见"xorTrie")</p>
<p><strong>带有 tag 的题</strong></p>
<p>数组里除了一个数外, 每个数都出现了两次, 求这个数.</p>
<p>解法: 全部异或.</p>
<p><strong>扩展:</strong> k 进制异或. 假如一个数组里每个数都出现了 k 次,
只有一个数除外. 那么 k 进制异或为: 对所有数二进制的每一位都记录模 k
意义下的位和. 这样保证空间复杂度 <span
class="math inline">\(O(\omega)\)</span>.</p>
<h4 id="回文串问题">回文串问题</h4>
<p><strong>性质</strong></p>
<p><strong>带有 tag 的题</strong></p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/600/problem/C">Problem - C -
Codeforces</a></p>
<p>正解是双指针, 从后向前遍历有反例: abcd, 正解 abbc, 假解 acca.</p>
<h4 id="凸性">凸性</h4>
<p>一些凸性结构往往也有有贪心结构, 难点在于证明吧 (反证居多)</p>
<p>给定数字 n 并且给出一种操作,
假如<strong>每次操作可选项不变</strong>且每次操作后 n
<strong>在全序意义下变化方向一致</strong>.</p>
<p><strong>定义 <span class="math inline">\(a_i\)</span> 是第 i
次操作后全序意义下的最值</strong>, 可考虑每次的变化值 <span
class="math inline">\(r_i = a_i - a_{i - 1}\)</span> 单调.</p>
<p>eg:</p>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/contest/2061/problem/E">Problem - E -
Codeforces</a></p>
<h2 id="ps-观察题">PS 观察题</h2>
<p><a target="_blank" rel="noopener" href="https://hydro.ac/p/bzoj-P3251">树上三角形 - 题目详情 -
Hydro</a></p>
<p><strong>题意</strong></p>
<p>给1e5 的有权树 ( 权值小于 <span class="math inline">\(2 ^
{31}\)</span> ), 有 1e5 次查询:</p>
<ul>
<li>op = 0: 给出点 a 和 b, 问 a 和 b 的简单路径上是否能找出三个点,
使得其权值组成一个三角形?</li>
<li>op = 1: <span class="math inline">\(v[a] := b\)</span></li>
</ul>
<p><strong>思路</strong></p>
<p>假如大小为 n 的可重集合中没有一组三角形, 那么最坏情况 (大小最大的)
构造是斐波那契数列.</p>
<p>注意到 <span class="math inline">\(n \geq 50\)</span> 时, <span
class="math inline">\(f(n) &gt; 2 ^ {31}\)</span>. 也就是说, 长度大于 50
的链一定合法. 所以大于 50 的链直接输出, 小于 50 的链暴力即可.</p>
<p>复杂度 <span class="math inline">\(O(k^2q\log k)\)</span>, 其中 k
是小于 50 的最长路径.</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">struct</span> <span class="title class_">edge</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> to, v;</span><br><span class="line">    <span class="built_in">edge</span>(<span class="type">int</span> a, <span class="type">int</span> b) &#123; to = a, v = b; &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Mikasa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, q;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; q;</span><br><span class="line">    <span class="function">vi <span class="title">v</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span>, <span class="title">deep</span><span class="params">(n + <span class="number">1</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">    vt&lt;vt&lt;edge&gt;&gt; <span class="built_in">e</span>(n + <span class="number">1</span>);</span><br><span class="line">    <span class="function">vt <span class="title">fa</span><span class="params">(n + <span class="number">1</span>, vi(log2(n) + <span class="number">5</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        cin &gt;&gt; v[i];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> a, b;</span><br><span class="line">        cin &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        e[a].<span class="built_in">push_back</span>(&#123;b, <span class="number">1</span>&#125;), e[b].<span class="built_in">push_back</span>(&#123;a, <span class="number">1</span>&#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> pre = [&amp;](<span class="type">int</span> n, <span class="type">int</span> s) -&gt; <span class="type">void</span></span><br><span class="line">    &#123;</span><br><span class="line">        vi <span class="built_in">done</span>(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        queue&lt;<span class="type">int</span>&gt; q;</span><br><span class="line">        q.<span class="built_in">push</span>(s), done[s] = <span class="number">1</span>, deep[s] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (q.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> now = q.<span class="built_in">front</span>();</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> [next, buf] : e[now])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (done[next])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                deep[next] = deep[now] + <span class="number">1</span>, fa[next][<span class="number">0</span>] = now;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= <span class="built_in">log2</span>(n) + <span class="number">1</span>; ++i)</span><br><span class="line">                    fa[next][i] = fa[fa[next][i - <span class="number">1</span>]][i - <span class="number">1</span>];</span><br><span class="line"></span><br><span class="line">                q.<span class="built_in">push</span>(next), done[next] = <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> lca = [&amp;](<span class="type">int</span> a, <span class="type">int</span> b) -&gt; <span class="type">int</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (deep[a] &lt; deep[b])</span><br><span class="line">            <span class="built_in">swap</span>(a, b);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">log2</span>(n) + <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> (deep[fa[a][i]] &gt;= deep[b])</span><br><span class="line">                a = fa[a][i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (a == b)</span><br><span class="line">            <span class="keyword">return</span> a;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="built_in">log2</span>(n) + <span class="number">1</span>; i &gt;= <span class="number">0</span>; --i)</span><br><span class="line">            <span class="keyword">if</span> (fa[a][i] != fa[b][i])</span><br><span class="line">                a = fa[a][i], b = fa[b][i];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> fa[a][<span class="number">0</span>];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">auto</span> check = [&amp;](vector&lt;<span class="type">int</span>&gt; &amp;have) -&gt; <span class="type">bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(have.<span class="built_in">begin</span>() + <span class="number">1</span>, have.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt; have.<span class="built_in">size</span>() - <span class="number">2</span>; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i + <span class="number">1</span>; j &lt; have.<span class="built_in">size</span>() - <span class="number">1</span>; ++j)</span><br><span class="line">                <span class="keyword">if</span> (have[j + <span class="number">1</span>] &lt; have[j] + have[i])</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">pre</span>(n, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (q--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> op, a, b;</span><br><span class="line">        cin &gt;&gt; op &gt;&gt; a &gt;&gt; b;</span><br><span class="line">        <span class="keyword">if</span> (op)</span><br><span class="line">            v[a] = b;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> f = <span class="built_in">lca</span>(a, b), len = deep[a] + deep[b] - <span class="number">2</span> * deep[f];</span><br><span class="line">            <span class="keyword">if</span> (len &gt;= <span class="number">50</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Y&quot;</span> &lt;&lt; endl;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function">vi <span class="title">have</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">            map&lt;<span class="type">int</span>, <span class="type">bool</span>&gt; done;</span><br><span class="line">            have.<span class="built_in">push_back</span>(v[f]);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> now = a; now != f; now = fa[now][<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">if</span> (!done[now])</span><br><span class="line">                    done[now] = <span class="number">1</span>, have.<span class="built_in">push_back</span>(v[now]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> now = b; now != f; now = fa[now][<span class="number">0</span>])</span><br><span class="line">                <span class="keyword">if</span> (!done[now])</span><br><span class="line">                    done[now] = <span class="number">1</span>, have.<span class="built_in">push_back</span>(v[now]);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">check</span>(have))</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Y&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;N&quot;</span> &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://codeforces.com/problemset/problem/1986/D">Problem -
1986D - Codeforces</a></p>
<p>给定一个数字构成的长度为 <span class="math inline">\(n(2 \leq n \leq
20)\)</span> 的字符串 s, 插入<span class="math inline">\(n -
2\)</span>个乘号或加号, 求结果的最小值</p>
<p>暴力复杂度<span class="math inline">\(O(tn2^{n - 1})\)</span>,
想一想贪心.</p>
<p><span class="math inline">\(n\)</span> 个数字有 <span
class="math inline">\(n - 1\)</span> 个空隙，插入<span
class="math inline">\(n - 2\)</span>个符号.
相当于n个数字里选两个相邻数字，视为一个整体. 注意到 0 和 1 ：0
乘任何数都是 0 ，所以尽可能拆成 0 和其它数相乘; 1
乘其它数不改变值，所以尽可能拆成 1 和其它数相乘. 除去 0、1
之外的数，都相加而非相乘</p>
<p>至于合并哪两个数字，暴力求：n 个里面选连续的两个(也就是选一个), 共
<span class="math inline">\(n - 1\)</span> 种情况. 复杂度<span
class="math inline">\(O(n^2t)\)</span></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> n;</span><br><span class="line">cin&gt;&gt;n;</span><br><span class="line">string s;</span><br><span class="line">cin&gt;&gt;s;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> ans = INF;</span><br><span class="line"><span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; ++ i)<span class="comment">//枚举第i和i+1个数字合并后，算式的最小值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//求第i个和i+1个数字合并之后的数组buf</span></span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; buf;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; n; ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(j != i &amp;&amp; j != i + <span class="number">1</span>)</span><br><span class="line">            buf.<span class="built_in">push_back</span>( s[j] - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> num = (s[i] - <span class="string">&#x27;0&#x27;</span>) * <span class="number">10</span> + s[i + <span class="number">1</span>] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            buf.<span class="built_in">push_back</span>(num);</span><br><span class="line">            j ++;<span class="comment">//在原数组中占两位</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//下面求buf组成算式的最小值tmp</span></span><br><span class="line">    <span class="type">int</span> tmp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; buf.<span class="built_in">size</span>(); ++ j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//有一项为0，最小值就是都乘起来，答案是0</span></span><br><span class="line">        <span class="keyword">if</span>(buf[j] == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="number">0</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//乘1不改变值，忽略</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(buf[j] == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//除了0和1外所有数都是相加</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            tmp += buf[j];</span><br><span class="line">    &#125;</span><br><span class="line">    ans = <span class="built_in">min</span>(ans, tmp);</span><br><span class="line">    <span class="comment">//注意到有特殊情况 ‘10’ 或 ‘101’ etc，执行到这一步时 ans 绝对不为 0，故对其与 1 取较大值即可</span></span><br><span class="line">    ans = <span class="built_in">max</span>((<span class="type">int</span>)<span class="number">1</span>, ans);</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;ans;</span><br><span class="line">cout&lt;&lt;endl;</span><br></pre></td></tr></table></figure>
<p><a
target="_blank" rel="noopener" href="https://codeforces.com/group/5YwhNALdOq/contest/591010/problem/C">Problem
- C - Codeforces</a></p>
<p>给一个只有字母 abc 的序列.</p>
<p>可以操作 ab := ba 或者 bc := cb, 问 s 能否变成 t ?</p>
<p><strong>题解</strong></p>
<p>注意到 ab := ba 等价于 a 后移一格, 同理 c 可以前移一格. 但是 c a
位置不能互换</p>
<p>故而: 除去所以 b 后的 s 等于 t; 并且 s 中所有 a 不能出现的比 t
中出现的晚, c 不能比 t 中早.</p>
<p><strong>反思</strong></p>
<p>我为什么没有想出来? 我的做法开始想到 b 有条件后移和前移. 但是 b
变化比较复杂, 所以不如思考 a 和 c.</p>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc203/tasks/abc203_d">D -
Pond</a></p>
<p><strong>题意</strong></p>
<p>给定 <span class="math inline">\(n\times n\)</span> 矩阵, 求所有
<span class="math inline">\(k\times k\)</span> 子矩阵中位数的最小值.
(<span class="math inline">\(k\leq n\leq 800\)</span>)</p>
<p><strong>思路</strong></p>
<p>注意到多次询问, 考虑转化成前缀和. 题目等价于 "第 p 大数的最小值",
故而考虑二分答案, 如何 <span class="math inline">\(O(n^2)\)</span> 判断?
中位数定义 <span class="math inline">\(\lceil{k^2\over
2}\rceil\)</span>-th 转化为 "范围内有至少 <span
class="math inline">\(\lceil{k^2\over 2}\rceil\)</span> 个数小于等于
now", 故而具有单调性. 只关心大小关系, 所以把原矩阵元素 <span
class="math inline">\(a_{ij}\)</span> 转化成 <span
class="math inline">\(b_{ij} = |a_{ij}\leq x|\)</span>. 复杂度 <span
class="math inline">\(O(n^2\log V)\)</span>.</p>
<p><strong>代码</strong></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">auto</span> <span class="title">Mikasa</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> n, k;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; k;</span><br><span class="line">    <span class="function">vt <span class="title">a</span><span class="params">(n + <span class="number">1</span>, vi(n + <span class="number">1</span>, <span class="number">0</span>))</span>, <span class="title">b</span><span class="params">(n + <span class="number">1</span>, vi(n + <span class="number">1</span>, <span class="number">0</span>))</span>, <span class="title">s</span><span class="params">(n + <span class="number">1</span>, vi(n + <span class="number">1</span>, <span class="number">0</span>))</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> v = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">            cin &gt;&gt; a[i][j], v = <span class="built_in">max</span>(v, a[i][j]);</span><br><span class="line"></span><br><span class="line">    function&lt;<span class="type">bool</span>(<span class="type">int</span>)&gt; check = [&amp;](<span class="type">int</span> x) -&gt; <span class="type">bool</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                b[i][j] = (<span class="type">bool</span>)(a[i][j] &lt;= x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n; ++j)</span><br><span class="line">                s[i][j] = s[i - <span class="number">1</span>][j] + s[i][j - <span class="number">1</span>] - s[i - <span class="number">1</span>][j - <span class="number">1</span>] + b[i][j];</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> cnt = (k * k + <span class="number">1</span>) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>; i + k - <span class="number">1</span> &lt;= n; ++i)</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = <span class="number">1</span>; j + k - <span class="number">1</span> &lt;= n; ++j)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> now = s[i + k - <span class="number">1</span>][j + k - <span class="number">1</span>] - s[i - <span class="number">1</span>][j + k - <span class="number">1</span>] - s[i + k - <span class="number">1</span>][j - <span class="number">1</span>] + s[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span> (now &gt;= cnt)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> l = <span class="number">0</span>, r = v;</span><br><span class="line">    <span class="keyword">while</span> (l &lt; r)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        (<span class="built_in">check</span>(mid)) ? (l = mid + <span class="number">1</span>) : (r = mid);</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; l &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a target="_blank" rel="noopener" href="https://atcoder.jp/contests/abc391/tasks/abc391_f">F - K-th
Largest Triplet</a></p>
<p>给三个数组a, b, c, 求: 第 K 大的<span class="math inline">\(a_i b_j +
a_i c_k + b_j c_k\)</span>.</p>
<p><strong>解法</strong></p>
<p>Top-K 算法.</p>
<p>对 <span class="math inline">\(a, b, c\)</span> 先降序排序, 注意到
<span class="math inline">\(f(i, j, k) \geq f(i + 1, j, k) / f(i, j + 1,
k) / f(i, j, k + 1)\)</span> .</p>
<p>因此，从大到小枚举数值时， <span
class="math inline">\(f(i,j,k)\)</span> 总是先枚举，然后是 <span
class="math inline">\(f(i+1,j,k),f(i,j+1,k),f(i,j,k+1)\)</span> 。</p>
<p>故而可以从 <span class="math inline">\((1, 1, 1)\)</span> 开始拓展,
每次把最大的 <span class="math inline">\(f(i, j, k)\)</span> 弹出来,
然后在优先队列里加入 <span class="math inline">\(f(i+1,j,k)\)</span>,
<span class="math inline">\(f(i,j+1,k)\)</span>, <span
class="math inline">\(f(i,j,k+1)\)</span>.</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.webp&quot;" data-lazy-src="/img/saki.webp" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.webp&quot;" data-lazy-src="/img/saki.webp" title="头像" alt="头像"></a><div class="post-copyright__author_name">Mikasa</div><div class="post-copyright__author_desc"></div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="https://blade-of-mikasa.github.io/2025/04/22/%E6%9D%BF%E5%AD%90%E5%90%88%E9%9B%86/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('https://blade-of-mikasa.github.io/2025/04/22/%E6%9D%BF%E5%AD%90%E5%90%88%E9%9B%86/')">板子合集</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="https://blade-of-mikasa.github.io/2025/04/22/%E6%9D%BF%E5%AD%90%E5%90%88%E9%9B%86/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=板子合集&amp;url=https://blade-of-mikasa.github.io/2025/04/22/%E6%9D%BF%E5%AD%90%E5%90%88%E9%9B%86/&amp;pic=/img/default_cover.webp" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://Blade-of-Mikasa.github.io" target="_blank">Mikasaの小屋</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"></div></div><div class="post_share"><div class="social-share" data-image="/img/default_cover.webp" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2025/04/22/2024%E5%B9%B4ICPC%E9%82%80%E8%AF%B7%E8%B5%9B-%E8%A5%BF%E5%AE%89%E7%AB%99/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.webp&quot;" data-lazy-src="/img/default_cover.webp" onerror="onerror=null;src='/img/404.webp'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">2024 icpc邀请赛-西安站</div></div></a></div><div class="next-post pull-right"><a href="/2025/04/23/2023%E5%B9%B4ICPC%E9%82%80%E8%AF%B7%E8%B5%9B-%E8%A5%BF%E5%AE%89%E7%AB%99/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.webp&quot;" data-lazy-src="/img/default_cover.webp" onerror="onerror=null;src='/img/404.webp'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">2023年ICPC邀请赛-西安站</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info__sayhi" id="author-info__sayhi" onclick="anzhiyu.changeSayHelloText()"></div><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.webp&quot;" data-lazy-src="/img/saki.webp" onerror="this.onerror=null;this.src='/img/friend_404.webp'" alt="avatar"/></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">Mikasa</h1><div class="author-info__desc"></div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/Blade-of-Mikasa" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#acm%E9%A2%98%E8%A7%A3"><span class="toc-number">1.</span> <span class="toc-text">ACM题解</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%96%B9%E9%92%88"><span class="toc-number">1.1.</span> <span class="toc-text">-3. 基本方针</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A6%82%E4%BD%95%E6%80%9D%E8%80%83"><span class="toc-number">1.1.0.1.</span> <span class="toc-text">如何思考?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%A6%E4%B9%A0%E8%B7%AF%E7%BA%BF"><span class="toc-number">1.1.0.2.</span> <span class="toc-text">学习路线!</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%A5%87%E5%A6%99%E6%80%9D%E8%B7%AF"><span class="toc-number">1.2.</span> <span class="toc-text">-2. 奇妙思路</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E9%82%A3%E4%B8%AA"><span class="toc-number">1.2.0.1.</span> <span class="toc-text">选择那个?</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E7%AD%94%E6%A1%88"><span class="toc-number">1.2.0.2.</span> <span class="toc-text">二分答案</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BC%A9%E5%87%8F%E8%8C%83%E5%9B%B4"><span class="toc-number">1.2.0.3.</span> <span class="toc-text">缩减范围</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E5%AF%B9%E8%B1%A1"><span class="toc-number">1.2.0.4.</span> <span class="toc-text">抽象对象</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%A8%A1%E6%9D%BF%E7%B1%BB"><span class="toc-number">1.3.</span> <span class="toc-text">-1. 基础模板类</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA"><span class="toc-number">1.3.0.1.</span> <span class="toc-text">快速输入输出</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#int128"><span class="toc-number">1.3.0.2.</span> <span class="toc-text">__int128</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%A7%E6%95%B4%E6%95%B0"><span class="toc-number">1.3.0.3.</span> <span class="toc-text">大整数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#z_p"><span class="toc-number">1.3.0.4.</span> <span class="toc-text">\(Z_p\)</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95"><span class="toc-number">1.4.</span> <span class="toc-text">0. 基础算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80-%E5%AE%8F"><span class="toc-number">1.4.0.1.</span> <span class="toc-text">前缀 &amp; 宏</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%BA%8F"><span class="toc-number">1.4.0.2.</span> <span class="toc-text">排序</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BA%8C%E5%88%86-%E4%B8%89%E5%88%86"><span class="toc-number">1.4.0.3.</span> <span class="toc-text">二分 &#x2F; 三分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E7%BC%80%E5%92%8C-%E5%B7%AE%E5%88%86"><span class="toc-number">1.4.0.4.</span> <span class="toc-text">前缀和 &#x2F; 差分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%BB%E6%95%A3%E5%8C%96"><span class="toc-number">1.4.0.5.</span> <span class="toc-text">离散化</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">1.4.0.6.</span> <span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E6%8C%87%E9%92%88"><span class="toc-number">1.4.0.7.</span> <span class="toc-text">双指针</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%90%9C%E7%B4%A2"><span class="toc-number">1.4.0.8.</span> <span class="toc-text">搜索</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92"><span class="toc-number">1.5.</span> <span class="toc-text">1. 动态规划</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7-dp"><span class="toc-number">1.5.1.</span> <span class="toc-text">1.1 线性 DP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E9%97%B4-dp"><span class="toc-number">1.5.2.</span> <span class="toc-text">1.2 区间 DP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A-dp"><span class="toc-number">1.5.3.</span> <span class="toc-text">1.3 特殊 DP</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#dp-%E4%BC%98%E5%8C%96"><span class="toc-number">1.5.4.</span> <span class="toc-text">1.? DP 优化</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83-%E6%9E%84%E9%80%A0"><span class="toc-number">1.6.</span> <span class="toc-text">2. 贪心 &#x2F; 构造</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9E%84%E9%80%A0"><span class="toc-number">1.6.1.</span> <span class="toc-text">构造</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%B4%AA%E5%BF%83"><span class="toc-number">1.6.2.</span> <span class="toc-text">贪心</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%BC%E5%90%88%E6%80%9D%E7%BB%B4"><span class="toc-number">1.6.3.</span> <span class="toc-text">综合思维</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E4%B8%B2"><span class="toc-number">1.7.</span> <span class="toc-text">3. 字符串</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E5%93%88%E5%B8%8C"><span class="toc-number">1.7.1.</span> <span class="toc-text">3.1 字符哈希</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91"><span class="toc-number">1.7.2.</span> <span class="toc-text">3.2 字典树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AD%97%E5%85%B8%E6%A0%91-1"><span class="toc-number">1.7.2.1.</span> <span class="toc-text">01字典树</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E5%AD%A6"><span class="toc-number">1.8.</span> <span class="toc-text">4. 数学</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E7%AE%97%E6%B3%95-1"><span class="toc-number">1.8.1.</span> <span class="toc-text">4.1 基础算法</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#gcd"><span class="toc-number">1.8.1.1.</span> <span class="toc-text">gcd</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E5%B9%82"><span class="toc-number">1.8.1.2.</span> <span class="toc-text">快速幂</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#exgcd"><span class="toc-number">1.8.1.3.</span> <span class="toc-text">EXGCD</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%80%86%E5%85%83"><span class="toc-number">1.8.1.4.</span> <span class="toc-text">逆元</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#mex"><span class="toc-number">1.8.1.5.</span> <span class="toc-text">mex</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA-%E7%BB%84%E5%90%88%E6%95%B0%E5%AD%A6"><span class="toc-number">1.8.2.</span> <span class="toc-text">4.2 数论 &amp; 组合数学</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B0%E8%AE%BA%E5%9F%BA%E7%A1%80"><span class="toc-number">1.8.2.1.</span> <span class="toc-text">数论基础</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%B4%A8%E6%95%B0"><span class="toc-number">1.8.2.2.</span> <span class="toc-text">质数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%96%90%E6%B3%A2%E9%82%A3%E5%A5%91"><span class="toc-number">1.8.2.3.</span> <span class="toc-text">斐波那契</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%BB%84%E5%90%88%E6%95%B0"><span class="toc-number">1.8.2.4.</span> <span class="toc-text">组合数</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%95%B4%E9%99%A4%E5%88%86%E5%9D%97"><span class="toc-number">1.8.2.5.</span> <span class="toc-text">整除分块</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%9A%E5%BC%88%E8%AE%BA"><span class="toc-number">1.8.3.</span> <span class="toc-text">4.3 博弈论</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.</span> <span class="toc-text">5. 数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">1.9.1.</span> <span class="toc-text">基础数据结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%B6%E6%9F%A5%E9%9B%86"><span class="toc-number">1.9.2.</span> <span class="toc-text">并查集</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84"><span class="toc-number">1.9.3.</span> <span class="toc-text">树状数组</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E6%AE%B5%E6%A0%91"><span class="toc-number">1.9.4.</span> <span class="toc-text">线段树</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9D%BF%E5%AD%90"><span class="toc-number">1.9.4.1.</span> <span class="toc-text">板子</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%80%9D%E6%83%B3"><span class="toc-number">1.9.4.2.</span> <span class="toc-text">思想</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E5%9D%97-%E8%8E%AB%E9%98%9F"><span class="toc-number">1.9.5.</span> <span class="toc-text">分块 &amp; 莫队</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E4%B8%8A%E9%97%AE%E9%A2%98"><span class="toc-number">1.10.</span> <span class="toc-text">6. 树上问题</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BB%BA%E6%A0%91%E5%92%8C%E9%81%8D%E5%8E%86"><span class="toc-number">1.10.0.1.</span> <span class="toc-text">建树和遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#lca"><span class="toc-number">1.10.0.2.</span> <span class="toc-text">LCA</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%AF%E5%8F%91%E5%BC%8F%E5%90%88%E5%B9%B6"><span class="toc-number">1.10.0.3.</span> <span class="toc-text">启发式合并</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#ps-%E7%A5%9E%E7%A7%98%E7%BB%93%E8%AE%BA"><span class="toc-number">1.10.0.4.</span> <span class="toc-text">PS 神秘结论</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E8%AE%BA"><span class="toc-number">1.11.</span> <span class="toc-text">7. 图论</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E5%9B%BE%E5%92%8C%E9%81%8D%E5%8E%86"><span class="toc-number">1.11.1.</span> <span class="toc-text">7.1 建图和遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E7%9F%AD%E8%B7%AF"><span class="toc-number">1.11.2.</span> <span class="toc-text">7.2 最短路</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91"><span class="toc-number">1.11.3.</span> <span class="toc-text">7.3 最小生成树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ps-%E7%A5%9E%E7%A7%98%E7%BB%93%E8%AE%BA-1"><span class="toc-number">1.11.4.</span> <span class="toc-text">PS 神秘结论</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%9F%93%E8%89%B2%E9%97%AE%E9%A2%98"><span class="toc-number">1.11.4.1.</span> <span class="toc-text">染色问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8B%89%E5%A7%86%E9%BD%90%E5%AE%9A%E7%90%86"><span class="toc-number">1.11.4.2.</span> <span class="toc-text">拉姆齐定理</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E5%87%A0%E4%BD%95"><span class="toc-number">1.12.</span> <span class="toc-text">8. 计算几何</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9D%82%E9%A1%B9"><span class="toc-number">1.13.</span> <span class="toc-text">9. 杂项</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A6%BB%E7%BA%BF"><span class="toc-number">1.13.0.1.</span> <span class="toc-text">离线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%A0%B9%E5%8F%B7%E5%88%86%E6%B2%BB"><span class="toc-number">1.13.0.2.</span> <span class="toc-text">根号分治</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B8%A6%E6%9D%83%E4%BA%8C%E5%88%86"><span class="toc-number">1.13.0.3.</span> <span class="toc-text">带权二分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%86%E6%95%B0%E8%A7%84%E5%88%92"><span class="toc-number">1.13.0.4.</span> <span class="toc-text">01分数规划</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%89%AB%E6%8F%8F%E7%BA%BF"><span class="toc-number">1.13.0.5.</span> <span class="toc-text">扫描线</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%AE%9A%E7%A7%AF%E5%88%86"><span class="toc-number">1.13.0.6.</span> <span class="toc-text">定积分</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E5%93%88%E5%B8%8C"><span class="toc-number">1.13.0.7.</span> <span class="toc-text">异或哈希</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E7%A5%9E%E7%A7%98%E7%BB%93%E8%AE%BA"><span class="toc-number">1.13.0.8.</span> <span class="toc-text">神秘结论</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%AA%97%E5%88%86%E7%AE%97%E6%B3%95"><span class="toc-number">1.13.0.9.</span> <span class="toc-text">骗分算法</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%89%AF%E5%A5%BD%E6%80%A7%E8%B4%A8-trick"><span class="toc-number">1.14.</span> <span class="toc-text">10. 良好性质 &amp; Trick</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#mex-%E9%97%AE%E9%A2%98"><span class="toc-number">1.14.0.1.</span> <span class="toc-text">mex 问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98"><span class="toc-number">1.14.0.2.</span> <span class="toc-text">排列问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BC%82%E6%88%96%E9%97%AE%E9%A2%98"><span class="toc-number">1.14.0.3.</span> <span class="toc-text">异或问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%9B%9E%E6%96%87%E4%B8%B2%E9%97%AE%E9%A2%98"><span class="toc-number">1.14.0.4.</span> <span class="toc-text">回文串问题</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%B8%E6%80%A7"><span class="toc-number">1.14.0.5.</span> <span class="toc-text">凸性</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ps-%E8%A7%82%E5%AF%9F%E9%A2%98"><span class="toc-number">1.15.</span> <span class="toc-text">PS 观察题</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2025/07/10/23%E7%BA%A7%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A311-%E7%BA%BF%E6%AE%B5%E6%A0%91/" title="23级集训题解11-线段树"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.webp&quot;" data-lazy-src="/img/default_cover.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="23级集训题解11-线段树"/></a><div class="content"><a class="title" href="/2025/07/10/23%E7%BA%A7%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A311-%E7%BA%BF%E6%AE%B5%E6%A0%91/" title="23级集训题解11-线段树">23级集训题解11-线段树</a><time datetime="2025-07-10T01:02:52.000Z" title="发表于 2025-07-10 09:02:52">2025-07-10</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/27/23%E7%BA%A7%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A35-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="23级集训题解5 树状数组"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.webp&quot;" data-lazy-src="/img/default_cover.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="23级集训题解5 树状数组"/></a><div class="content"><a class="title" href="/2025/06/27/23%E7%BA%A7%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A35-%E6%A0%91%E7%8A%B6%E6%95%B0%E7%BB%84/" title="23级集训题解5 树状数组">23级集训题解5 树状数组</a><time datetime="2025-06-27T02:12:04.000Z" title="发表于 2025-06-27 10:12:04">2025-06-27</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/26/24%E7%BA%A7%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/" title="24级集训题解 数据结构(2)"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.webp&quot;" data-lazy-src="/img/default_cover.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="24级集训题解 数据结构(2)"/></a><div class="content"><a class="title" href="/2025/06/26/24%E7%BA%A7%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A3-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-2/" title="24级集训题解 数据结构(2)">24级集训题解 数据结构(2)</a><time datetime="2025-06-26T14:45:54.000Z" title="发表于 2025-06-26 22:45:54">2025-06-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/26/23%E7%BA%A7%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A34-%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="23级集训题解4 并查集"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.webp&quot;" data-lazy-src="/img/default_cover.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="23级集训题解4 并查集"/></a><div class="content"><a class="title" href="/2025/06/26/23%E7%BA%A7%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A34-%E5%B9%B6%E6%9F%A5%E9%9B%86/" title="23级集训题解4 并查集">23级集训题解4 并查集</a><time datetime="2025-06-26T02:02:46.000Z" title="发表于 2025-06-26 10:02:46">2025-06-26</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2025/06/23/23%E7%BA%A7%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A31-%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83/" title="23级集训题解1 康复训练"><img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.webp&quot;" data-lazy-src="/img/default_cover.webp" onerror="this.onerror=null;this.src='/img/404.webp'" alt="23级集训题解1 康复训练"/></a><div class="content"><a class="title" href="/2025/06/23/23%E7%BA%A7%E9%9B%86%E8%AE%AD%E9%A2%98%E8%A7%A31-%E5%BA%B7%E5%A4%8D%E8%AE%AD%E7%BB%83/" title="23级集训题解1 康复训练">23级集训题解1 康复训练</a><time datetime="2025-06-23T14:31:17.000Z" title="发表于 2025-06-23 22:31:17">2025-06-23</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2025 By <a class="footer-bar-link" href="/" title="Mikasa" target="_blank">Mikasa</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">50</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">27</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">0</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.webp&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.webp&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/Atcoder/" style="font-size: 0.88rem;">Atcoder<sup>3</sup></a><a href="/tags/CF/" style="font-size: 0.88rem;">CF<sup>2</sup></a><a href="/tags/CMC/" style="font-size: 0.88rem;">CMC<sup>1</sup></a><a href="/tags/Codeforces/" style="font-size: 0.88rem;">Codeforces<sup>20</sup></a><a href="/tags/DP/" style="font-size: 0.88rem;">DP<sup>1</sup></a><a href="/tags/ICPC/" style="font-size: 0.88rem;">ICPC<sup>2</sup></a><a href="/tags/Trick/" style="font-size: 0.88rem;">Trick<sup>1</sup></a><a href="/tags/XCPC/" style="font-size: 0.88rem;">XCPC<sup>1</sup></a><a href="/tags/ZCMU/" style="font-size: 0.88rem;">ZCMU<sup>1</sup></a><a href="/tags/abc/" style="font-size: 0.88rem;">abc<sup>3</sup></a><a href="/tags/div1-2/" style="font-size: 0.88rem;">div1+2<sup>1</sup></a><a href="/tags/div2/" style="font-size: 0.88rem;">div2<sup>5</sup></a><a href="/tags/div3/" style="font-size: 0.88rem;">div3<sup>7</sup></a><a href="/tags/div4/" style="font-size: 0.88rem;">div4<sup>4</sup></a><a href="/tags/education/" style="font-size: 0.88rem;">education<sup>3</sup></a><a href="/tags/xcpc/" style="font-size: 0.88rem;">xcpc<sup>1</sup></a><a href="/tags/%E4%B8%93%E9%A2%98/" style="font-size: 0.88rem;">专题<sup>3</sup></a><a href="/tags/%E4%BA%A4%E4%BA%92/" style="font-size: 0.88rem;">交互<sup>1</sup></a><a href="/tags/%E5%96%B5%E5%96%B5%E9%A2%98/" style="font-size: 0.88rem;">喵喵题<sup>1</sup></a><a href="/tags/%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">数学<sup>2</sup></a><a href="/tags/%E6%9D%BF%E5%88%B7/" style="font-size: 0.88rem;">板刷<sup>3</sup></a><a href="/tags/%E6%9D%BF%E5%88%B7%E8%AE%B0%E5%BD%95/" style="font-size: 0.88rem;">板刷记录<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>37</sup></a><a href="/tags/%E7%BA%BF%E6%AE%B5%E6%A0%91/" style="font-size: 0.88rem;">线段树<sup>1</sup></a><a href="/tags/%E9%82%80%E8%AF%B7%E8%B5%9B/" style="font-size: 0.88rem;">邀请赛<sup>3</sup></a><a href="/tags/%E9%9B%86%E8%AE%AD/" style="font-size: 0.88rem;">集训<sup>3</sup></a><a href="/tags/%E9%AB%98%E7%AD%89%E6%95%B0%E5%AD%A6/" style="font-size: 0.88rem;">高等数学<sup>2</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="365072488" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;null&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date(""); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.14",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 Mikasa 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><script>if (!window.MathJax) {
  window.MathJax = {
    tex: {
      inlineMath: [['$', '$'], ['\\(', '\\)']],
      tags: 'ams'
    },
    chtml: {
      scale: 1.1
    },
    options: {
      renderActions: {
        findScript: [10, doc => {
          for (const node of document.querySelectorAll('script[type^="math/tex"]')) {
            const display = !!node.type.match(/; *mode=display/)
            const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display)
            const text = document.createTextNode('')
            node.parentNode.replaceChild(text, node)
            math.start = {node: text, delim: '', n: 0}
            math.end = {node: text, delim: '', n: 0}
            doc.math.push(math)
          }
        }, '']
      }
    }
  }
  
  const script = document.createElement('script')
  script.src = 'https://cdn.cbd.int/mathjax@3.2.2/es5/tex-mml-chtml.js'
  script.id = 'MathJax-script'
  script.async = true
  document.head.appendChild(script)
} else {
  MathJax.startup.document.state(0)
  MathJax.texReset()
  MathJax.typesetPromise()
}</script><input type="hidden" name="page-type" id="page-type" value="post"></div><script async data-pjax src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.1/bubble/bubble.js"></script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><canvas class="fireworks" mobile="true"></canvas><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/dist/fireworks.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>